<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>secfsdstools.e_read.basereportreading API documentation</title>
<meta name="description" content="base logic for reporting classes" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>secfsdstools.e_read.basereportreading</code></h1>
</header>
<section id="section-intro">
<p>base logic for reporting classes</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
base logic for reporting classes
&#34;&#34;&#34;

from abc import ABC, abstractmethod
from typing import List, Optional, Dict

import pandas as pd

from secfsdstools.a_utils.constants import NUM_TXT, PRE_TXT, SUB_TXT


def match_group_iter(match_iter):
    &#34;&#34;&#34;
    returns an iterator that returns the group() of the matching iterator
    Args:
        match_iter: a re match iterator

    Returns:
        group content iterator
    &#34;&#34;&#34;
    for match in match_iter:
        yield match.group()


class BaseReportReader(ABC):
    &#34;&#34;&#34;
    BaseReportReader
    &#34;&#34;&#34;

    def __init__(self):
        self.num_df: Optional[pd.DataFrame] = None
        self.pre_df: Optional[pd.DataFrame] = None
        self.sub_df: Optional[pd.DataFrame] = None
        self.adsh_form_map: Optional[Dict[str, int]] = None
        self.adsh_period_map: Optional[Dict[str, int]] = None
        self.adsh_previous_map: Optional[Dict[str, int]] = {}

    @staticmethod
    def _calculate_previous_period(period: int) -&gt; int:
        previous_value = period - 10_000
        period_year, period_monthday = divmod(period, 10_000)

        # is the period date on a 29th of Feb, then the previous period has to end on a 28th Feb
        if period % 10_000 == 229:
            previous_value = previous_value - 1

        # was the previous year a leap year and is the period for end of february
        if (((period_year - 1) % 4) == 0) &amp; (period_monthday == 228):
            previous_value = previous_value + 1

        return previous_value

    def _read_raw_data(self):
        &#34;&#34;&#34;
        read the raw data from the num and pre file into dataframes and store them
        inside the object. used in a lazy loading manner.
        &#34;&#34;&#34;
        if self.num_df is None:
            self.num_df = self._read_df_from_raw(file=NUM_TXT)
            self.pre_df = self._read_df_from_raw(file=PRE_TXT)
            self.sub_df = self._read_df_from_raw(file=SUB_TXT)

            # pandas pivot works better if coreg is not nan, so we set it here to a simple dash
            self.num_df.loc[self.num_df.coreg.isna(), &#39;coreg&#39;] = &#39;-&#39;

            self.adsh_form_map = \
                self.sub_df[[&#39;adsh&#39;, &#39;form&#39;]].set_index(&#39;adsh&#39;).to_dict()[&#39;form&#39;]
            self.adsh_period_map = \
                self.sub_df[[&#39;adsh&#39;, &#39;period&#39;]].set_index(&#39;adsh&#39;).to_dict()[&#39;period&#39;]

            # caculate the date for the previous year
            self.adsh_previous_map = {adsh: BaseReportReader._calculate_previous_period(period)
                                      for adsh, period in self.adsh_period_map.items()}

    def get_raw_num_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns a copy of the raw dataframe for the num.txt file of this report

        Returns:
            pd.DataFrame: pandas dataframe
        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        return self.num_df.copy()

    def get_raw_pre_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns a copy of the raw dataframe for the pre.txt file of this report

        Returns:
            pd.DataFrame: pandas dataframe
        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        return self.pre_df.copy()

    def get_raw_sub_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns a copy of the raw dataframe for the sub.txt file of this report

        Returns:
            pd.DataFrame: pandas dataframe
        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        return self.sub_df.copy()

    def merge_pre_and_num(self,
                          use_period: bool = True,
                          use_previous_period: bool = False,
                          tags: Optional[List[str]] = None,
                          ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        merges the raw data of pre and num together.
        depending on the parameters, it just uses the  period date and the previouis period date.
        furthermore, also the tags could be restricted.

        Note: default for use_period is True

        Args:
            use_period (bool, True): indicates that only the values are filtered which
            ddates machtes the period of the report.

            use_previous_period (bool, False): indicates that only the values  are filtered
            which ddates matches the period of the report and the previous year. If this is set
            to True, then the value of use_period is ignored

            tags (List[str], optional, None): if set, only the tags listet in this
            parameter are returned
        Returns:
            pd.DataFrame: pandas dataframe

        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        num_df_filtered_for_dates = self.num_df

        ## only consider the entries in num.df that have ddates according to the set
        ## use_report and use_previoius_report

        # if use_previous_report, then use_period is ignored
        if use_period and not use_previous_period:
            mask = self.num_df[&#39;adsh&#39;].map(self.adsh_period_map) == self.num_df[&#39;ddate&#39;]
            num_df_filtered_for_dates = num_df_filtered_for_dates[mask]

        if use_previous_period:
            mask = (self.num_df[&#39;adsh&#39;].map(self.adsh_period_map) == self.num_df[&#39;ddate&#39;]) | \
                   (self.num_df[&#39;adsh&#39;].map(self.adsh_previous_map) == self.num_df[&#39;ddate&#39;])

            num_df_filtered_for_dates = num_df_filtered_for_dates[mask]

        ## only consider the entries in pre which tag names are defined in the tags parameter
        pre_filtered_for_tags = self.pre_df
        if tags:
            pre_filtered_for_tags = self.pre_df[self.pre_df.tag.isin(tags)]

        ## transform the data
        # merge num and pre together. only rows in num are considered for which entries in pre exist
        return pd.merge(num_df_filtered_for_dates,
                        pre_filtered_for_tags,
                        on=[&#39;adsh&#39;, &#39;tag&#39;, &#39;version&#39;]) # don&#39;t produce index_x and index_y columns

    def financial_statements_for_tags(self,
                                      use_period: bool = True,
                                      use_previous_period: bool = False,
                                      tags: Optional[List[str]] = None,
                                      ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        formats the raw data in a way, that it reflects the presentation of the
        primary financial statements (balance sheet, income statement, cash flow)
        of the original filed report. Meaning the statements are grouped per report
        and per type and have the same order as they appear in the report itself.
        moreover, the data is pivoted, so that every ddate has its own column

        Args:
            use_period (bool, True): indicates that only the values are filtered which
            ddates machtes the period of the report.

            use_previous_period (bool, False): indicates that only the values  are filtered
            which ddates matches the period of the report and the previous year. If this is set
            to True, then the value of use_period is ignored

            tags (List[str], optional, None): if set, only the tags listet in this
            parameter are returned

        Returns:
            pd.DataFrame: the filtered and transformed data
        &#34;&#34;&#34;

        ## transform the data
        # merge num and pre together. only rows in num are considered for which entries in pre exist
        num_pre_merged_df = self.merge_pre_and_num(use_period=use_period,
                                                   use_previous_period=use_previous_period,
                                                   tags=tags)

        # pivot the data, so that ddate appears as a column
        num_pre_merged_pivot_df = num_pre_merged_df.pivot_table(
            index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;stmt&#39;,
                   &#39;report&#39;, &#39;line&#39;, &#39;uom&#39;, &#39;negating&#39;, &#39;inpth&#39;],
            columns=&#39;ddate&#39;,
            values=&#39;value&#39;)

        # some cleanup and ordering
        num_pre_merged_pivot_df.rename_axis(None, axis=1, inplace=True)
        num_pre_merged_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;stmt&#39;, &#39;report&#39;, &#39;line&#39;, &#39;inpth&#39;],
                                            inplace=True)
        num_pre_merged_pivot_df.reset_index(drop=False, inplace=True)

        # adding the report type as an additional column
        num_pre_merged_pivot_df[&#39;form&#39;] = num_pre_merged_pivot_df[&#39;adsh&#39;].map(self.adsh_form_map)

        # the values for ddate are ints, not string
        # if we pivot, then the column names stay ints, which is unuexpected, so we change the
        # the type of the column to strings
        num_pre_merged_pivot_df.rename(columns={x: str(x) for x in num_pre_merged_pivot_df.columns},
                                       inplace=True)

        return num_pre_merged_pivot_df

    def financial_statements_for_period(self, tags: Optional[List[str]] = None, ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns the merged and pivoted table for the of the num-
         and predata for the current date only
        Args:
            tags (List[str], optional): List with tags to include or None

        Returns:
            pd.Dataframe: pandas dataframe
        &#34;&#34;&#34;
        return self.financial_statements_for_tags(use_period=True, tags=tags)

    def financial_statements_for_period_and_previous_period(
            self, tags: Optional[List[str]] = None, ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns the merged and pivoted table for the of the num-
         and predata for the current and the date
         of the same period a year ago.

        Args:
            tags (List[str], optional): List with tags to include or None

        Returns:
            pd.Dataframe: pandas dataframe
        &#34;&#34;&#34;

        return self.financial_statements_for_tags(use_previous_period=True, tags=tags)

    @abstractmethod
    def _read_df_from_raw(self,
                          file: str) \
            -&gt; pd.DataFrame:
        &#34;&#34;&#34;

        Args:
            file: SUB_TXT, PRE_TXT, or NUM_TXT

        Returns:
            pd.DataFrame: the content for the read filetype
        &#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="secfsdstools.e_read.basereportreading.match_group_iter"><code class="name flex">
<span>def <span class="ident">match_group_iter</span></span>(<span>match_iter)</span>
</code></dt>
<dd>
<div class="desc"><p>returns an iterator that returns the group() of the matching iterator</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>match_iter</code></strong></dt>
<dd>a re match iterator</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>group content iterator</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_group_iter(match_iter):
    &#34;&#34;&#34;
    returns an iterator that returns the group() of the matching iterator
    Args:
        match_iter: a re match iterator

    Returns:
        group content iterator
    &#34;&#34;&#34;
    for match in match_iter:
        yield match.group()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader"><code class="flex name class">
<span>class <span class="ident">BaseReportReader</span></span>
</code></dt>
<dd>
<div class="desc"><p>BaseReportReader</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseReportReader(ABC):
    &#34;&#34;&#34;
    BaseReportReader
    &#34;&#34;&#34;

    def __init__(self):
        self.num_df: Optional[pd.DataFrame] = None
        self.pre_df: Optional[pd.DataFrame] = None
        self.sub_df: Optional[pd.DataFrame] = None
        self.adsh_form_map: Optional[Dict[str, int]] = None
        self.adsh_period_map: Optional[Dict[str, int]] = None
        self.adsh_previous_map: Optional[Dict[str, int]] = {}

    @staticmethod
    def _calculate_previous_period(period: int) -&gt; int:
        previous_value = period - 10_000
        period_year, period_monthday = divmod(period, 10_000)

        # is the period date on a 29th of Feb, then the previous period has to end on a 28th Feb
        if period % 10_000 == 229:
            previous_value = previous_value - 1

        # was the previous year a leap year and is the period for end of february
        if (((period_year - 1) % 4) == 0) &amp; (period_monthday == 228):
            previous_value = previous_value + 1

        return previous_value

    def _read_raw_data(self):
        &#34;&#34;&#34;
        read the raw data from the num and pre file into dataframes and store them
        inside the object. used in a lazy loading manner.
        &#34;&#34;&#34;
        if self.num_df is None:
            self.num_df = self._read_df_from_raw(file=NUM_TXT)
            self.pre_df = self._read_df_from_raw(file=PRE_TXT)
            self.sub_df = self._read_df_from_raw(file=SUB_TXT)

            # pandas pivot works better if coreg is not nan, so we set it here to a simple dash
            self.num_df.loc[self.num_df.coreg.isna(), &#39;coreg&#39;] = &#39;-&#39;

            self.adsh_form_map = \
                self.sub_df[[&#39;adsh&#39;, &#39;form&#39;]].set_index(&#39;adsh&#39;).to_dict()[&#39;form&#39;]
            self.adsh_period_map = \
                self.sub_df[[&#39;adsh&#39;, &#39;period&#39;]].set_index(&#39;adsh&#39;).to_dict()[&#39;period&#39;]

            # caculate the date for the previous year
            self.adsh_previous_map = {adsh: BaseReportReader._calculate_previous_period(period)
                                      for adsh, period in self.adsh_period_map.items()}

    def get_raw_num_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns a copy of the raw dataframe for the num.txt file of this report

        Returns:
            pd.DataFrame: pandas dataframe
        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        return self.num_df.copy()

    def get_raw_pre_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns a copy of the raw dataframe for the pre.txt file of this report

        Returns:
            pd.DataFrame: pandas dataframe
        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        return self.pre_df.copy()

    def get_raw_sub_data(self) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns a copy of the raw dataframe for the sub.txt file of this report

        Returns:
            pd.DataFrame: pandas dataframe
        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        return self.sub_df.copy()

    def merge_pre_and_num(self,
                          use_period: bool = True,
                          use_previous_period: bool = False,
                          tags: Optional[List[str]] = None,
                          ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        merges the raw data of pre and num together.
        depending on the parameters, it just uses the  period date and the previouis period date.
        furthermore, also the tags could be restricted.

        Note: default for use_period is True

        Args:
            use_period (bool, True): indicates that only the values are filtered which
            ddates machtes the period of the report.

            use_previous_period (bool, False): indicates that only the values  are filtered
            which ddates matches the period of the report and the previous year. If this is set
            to True, then the value of use_period is ignored

            tags (List[str], optional, None): if set, only the tags listet in this
            parameter are returned
        Returns:
            pd.DataFrame: pandas dataframe

        &#34;&#34;&#34;
        self._read_raw_data()  # lazy load the data if necessary
        num_df_filtered_for_dates = self.num_df

        ## only consider the entries in num.df that have ddates according to the set
        ## use_report and use_previoius_report

        # if use_previous_report, then use_period is ignored
        if use_period and not use_previous_period:
            mask = self.num_df[&#39;adsh&#39;].map(self.adsh_period_map) == self.num_df[&#39;ddate&#39;]
            num_df_filtered_for_dates = num_df_filtered_for_dates[mask]

        if use_previous_period:
            mask = (self.num_df[&#39;adsh&#39;].map(self.adsh_period_map) == self.num_df[&#39;ddate&#39;]) | \
                   (self.num_df[&#39;adsh&#39;].map(self.adsh_previous_map) == self.num_df[&#39;ddate&#39;])

            num_df_filtered_for_dates = num_df_filtered_for_dates[mask]

        ## only consider the entries in pre which tag names are defined in the tags parameter
        pre_filtered_for_tags = self.pre_df
        if tags:
            pre_filtered_for_tags = self.pre_df[self.pre_df.tag.isin(tags)]

        ## transform the data
        # merge num and pre together. only rows in num are considered for which entries in pre exist
        return pd.merge(num_df_filtered_for_dates,
                        pre_filtered_for_tags,
                        on=[&#39;adsh&#39;, &#39;tag&#39;, &#39;version&#39;]) # don&#39;t produce index_x and index_y columns

    def financial_statements_for_tags(self,
                                      use_period: bool = True,
                                      use_previous_period: bool = False,
                                      tags: Optional[List[str]] = None,
                                      ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        formats the raw data in a way, that it reflects the presentation of the
        primary financial statements (balance sheet, income statement, cash flow)
        of the original filed report. Meaning the statements are grouped per report
        and per type and have the same order as they appear in the report itself.
        moreover, the data is pivoted, so that every ddate has its own column

        Args:
            use_period (bool, True): indicates that only the values are filtered which
            ddates machtes the period of the report.

            use_previous_period (bool, False): indicates that only the values  are filtered
            which ddates matches the period of the report and the previous year. If this is set
            to True, then the value of use_period is ignored

            tags (List[str], optional, None): if set, only the tags listet in this
            parameter are returned

        Returns:
            pd.DataFrame: the filtered and transformed data
        &#34;&#34;&#34;

        ## transform the data
        # merge num and pre together. only rows in num are considered for which entries in pre exist
        num_pre_merged_df = self.merge_pre_and_num(use_period=use_period,
                                                   use_previous_period=use_previous_period,
                                                   tags=tags)

        # pivot the data, so that ddate appears as a column
        num_pre_merged_pivot_df = num_pre_merged_df.pivot_table(
            index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;stmt&#39;,
                   &#39;report&#39;, &#39;line&#39;, &#39;uom&#39;, &#39;negating&#39;, &#39;inpth&#39;],
            columns=&#39;ddate&#39;,
            values=&#39;value&#39;)

        # some cleanup and ordering
        num_pre_merged_pivot_df.rename_axis(None, axis=1, inplace=True)
        num_pre_merged_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;stmt&#39;, &#39;report&#39;, &#39;line&#39;, &#39;inpth&#39;],
                                            inplace=True)
        num_pre_merged_pivot_df.reset_index(drop=False, inplace=True)

        # adding the report type as an additional column
        num_pre_merged_pivot_df[&#39;form&#39;] = num_pre_merged_pivot_df[&#39;adsh&#39;].map(self.adsh_form_map)

        # the values for ddate are ints, not string
        # if we pivot, then the column names stay ints, which is unuexpected, so we change the
        # the type of the column to strings
        num_pre_merged_pivot_df.rename(columns={x: str(x) for x in num_pre_merged_pivot_df.columns},
                                       inplace=True)

        return num_pre_merged_pivot_df

    def financial_statements_for_period(self, tags: Optional[List[str]] = None, ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns the merged and pivoted table for the of the num-
         and predata for the current date only
        Args:
            tags (List[str], optional): List with tags to include or None

        Returns:
            pd.Dataframe: pandas dataframe
        &#34;&#34;&#34;
        return self.financial_statements_for_tags(use_period=True, tags=tags)

    def financial_statements_for_period_and_previous_period(
            self, tags: Optional[List[str]] = None, ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;
        returns the merged and pivoted table for the of the num-
         and predata for the current and the date
         of the same period a year ago.

        Args:
            tags (List[str], optional): List with tags to include or None

        Returns:
            pd.Dataframe: pandas dataframe
        &#34;&#34;&#34;

        return self.financial_statements_for_tags(use_previous_period=True, tags=tags)

    @abstractmethod
    def _read_df_from_raw(self,
                          file: str) \
            -&gt; pd.DataFrame:
        &#34;&#34;&#34;

        Args:
            file: SUB_TXT, PRE_TXT, or NUM_TXT

        Returns:
            pd.DataFrame: the content for the read filetype
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.e_read.multireportreading.MultiReportReader" href="multireportreading.html#secfsdstools.e_read.multireportreading.MultiReportReader">MultiReportReader</a></li>
<li><a title="secfsdstools.e_read.reportreading.ReportReader" href="reportreading.html#secfsdstools.e_read.reportreading.ReportReader">ReportReader</a></li>
<li><a title="secfsdstools.e_read.zipreportreading.ZipReportReader" href="zipreportreading.html#secfsdstools.e_read.zipreportreading.ZipReportReader">ZipReportReader</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_period"><code class="name flex">
<span>def <span class="ident">financial_statements_for_period</span></span>(<span>self, tags: Optional[List[str]] = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>returns the merged and pivoted table for the of the num-
and predata for the current date only</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List with tags to include or None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Dataframe</code></dt>
<dd>pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def financial_statements_for_period(self, tags: Optional[List[str]] = None, ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    returns the merged and pivoted table for the of the num-
     and predata for the current date only
    Args:
        tags (List[str], optional): List with tags to include or None

    Returns:
        pd.Dataframe: pandas dataframe
    &#34;&#34;&#34;
    return self.financial_statements_for_tags(use_period=True, tags=tags)</code></pre>
</details>
</dd>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_period_and_previous_period"><code class="name flex">
<span>def <span class="ident">financial_statements_for_period_and_previous_period</span></span>(<span>self, tags: Optional[List[str]] = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>returns the merged and pivoted table for the of the num-
and predata for the current and the date
of the same period a year ago.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>List[str]</code>, optional</dt>
<dd>List with tags to include or None</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Dataframe</code></dt>
<dd>pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def financial_statements_for_period_and_previous_period(
        self, tags: Optional[List[str]] = None, ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    returns the merged and pivoted table for the of the num-
     and predata for the current and the date
     of the same period a year ago.

    Args:
        tags (List[str], optional): List with tags to include or None

    Returns:
        pd.Dataframe: pandas dataframe
    &#34;&#34;&#34;

    return self.financial_statements_for_tags(use_previous_period=True, tags=tags)</code></pre>
</details>
</dd>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_tags"><code class="name flex">
<span>def <span class="ident">financial_statements_for_tags</span></span>(<span>self, use_period: bool = True, use_previous_period: bool = False, tags: Optional[List[str]] = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>formats the raw data in a way, that it reflects the presentation of the
primary financial statements (balance sheet, income statement, cash flow)
of the original filed report. Meaning the statements are grouped per report
and per type and have the same order as they appear in the report itself.
moreover, the data is pivoted, so that every ddate has its own column</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_period</code></strong> :&ensp;<code>bool, True</code></dt>
<dd>indicates that only the values are filtered which</dd>
</dl>
<p>ddates machtes the period of the report.</p>
<dl>
<dt><strong><code>use_previous_period</code></strong> :&ensp;<code>bool, False</code></dt>
<dd>indicates that only the values
are filtered</dd>
</dl>
<p>which ddates matches the period of the report and the previous year. If this is set
to True, then the value of use_period is ignored</p>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>List[str]</code>, optional<code>, None</code></dt>
<dd>if set, only the tags listet in this</dd>
</dl>
<p>parameter are returned</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>the filtered and transformed data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def financial_statements_for_tags(self,
                                  use_period: bool = True,
                                  use_previous_period: bool = False,
                                  tags: Optional[List[str]] = None,
                                  ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    formats the raw data in a way, that it reflects the presentation of the
    primary financial statements (balance sheet, income statement, cash flow)
    of the original filed report. Meaning the statements are grouped per report
    and per type and have the same order as they appear in the report itself.
    moreover, the data is pivoted, so that every ddate has its own column

    Args:
        use_period (bool, True): indicates that only the values are filtered which
        ddates machtes the period of the report.

        use_previous_period (bool, False): indicates that only the values  are filtered
        which ddates matches the period of the report and the previous year. If this is set
        to True, then the value of use_period is ignored

        tags (List[str], optional, None): if set, only the tags listet in this
        parameter are returned

    Returns:
        pd.DataFrame: the filtered and transformed data
    &#34;&#34;&#34;

    ## transform the data
    # merge num and pre together. only rows in num are considered for which entries in pre exist
    num_pre_merged_df = self.merge_pre_and_num(use_period=use_period,
                                               use_previous_period=use_previous_period,
                                               tags=tags)

    # pivot the data, so that ddate appears as a column
    num_pre_merged_pivot_df = num_pre_merged_df.pivot_table(
        index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;stmt&#39;,
               &#39;report&#39;, &#39;line&#39;, &#39;uom&#39;, &#39;negating&#39;, &#39;inpth&#39;],
        columns=&#39;ddate&#39;,
        values=&#39;value&#39;)

    # some cleanup and ordering
    num_pre_merged_pivot_df.rename_axis(None, axis=1, inplace=True)
    num_pre_merged_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;stmt&#39;, &#39;report&#39;, &#39;line&#39;, &#39;inpth&#39;],
                                        inplace=True)
    num_pre_merged_pivot_df.reset_index(drop=False, inplace=True)

    # adding the report type as an additional column
    num_pre_merged_pivot_df[&#39;form&#39;] = num_pre_merged_pivot_df[&#39;adsh&#39;].map(self.adsh_form_map)

    # the values for ddate are ints, not string
    # if we pivot, then the column names stay ints, which is unuexpected, so we change the
    # the type of the column to strings
    num_pre_merged_pivot_df.rename(columns={x: str(x) for x in num_pre_merged_pivot_df.columns},
                                   inplace=True)

    return num_pre_merged_pivot_df</code></pre>
</details>
</dd>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_num_data"><code class="name flex">
<span>def <span class="ident">get_raw_num_data</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of the raw dataframe for the num.txt file of this report</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_num_data(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    returns a copy of the raw dataframe for the num.txt file of this report

    Returns:
        pd.DataFrame: pandas dataframe
    &#34;&#34;&#34;
    self._read_raw_data()  # lazy load the data if necessary
    return self.num_df.copy()</code></pre>
</details>
</dd>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_pre_data"><code class="name flex">
<span>def <span class="ident">get_raw_pre_data</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of the raw dataframe for the pre.txt file of this report</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_pre_data(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    returns a copy of the raw dataframe for the pre.txt file of this report

    Returns:
        pd.DataFrame: pandas dataframe
    &#34;&#34;&#34;
    self._read_raw_data()  # lazy load the data if necessary
    return self.pre_df.copy()</code></pre>
</details>
</dd>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_sub_data"><code class="name flex">
<span>def <span class="ident">get_raw_sub_data</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>returns a copy of the raw dataframe for the sub.txt file of this report</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_raw_sub_data(self) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    returns a copy of the raw dataframe for the sub.txt file of this report

    Returns:
        pd.DataFrame: pandas dataframe
    &#34;&#34;&#34;
    self._read_raw_data()  # lazy load the data if necessary
    return self.sub_df.copy()</code></pre>
</details>
</dd>
<dt id="secfsdstools.e_read.basereportreading.BaseReportReader.merge_pre_and_num"><code class="name flex">
<span>def <span class="ident">merge_pre_and_num</span></span>(<span>self, use_period: bool = True, use_previous_period: bool = False, tags: Optional[List[str]] = None) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>merges the raw data of pre and num together.
depending on the parameters, it just uses the
period date and the previouis period date.
furthermore, also the tags could be restricted.</p>
<p>Note: default for use_period is True</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>use_period</code></strong> :&ensp;<code>bool, True</code></dt>
<dd>indicates that only the values are filtered which</dd>
</dl>
<p>ddates machtes the period of the report.</p>
<dl>
<dt><strong><code>use_previous_period</code></strong> :&ensp;<code>bool, False</code></dt>
<dd>indicates that only the values
are filtered</dd>
</dl>
<p>which ddates matches the period of the report and the previous year. If this is set
to True, then the value of use_period is ignored</p>
<dl>
<dt><strong><code>tags</code></strong> :&ensp;<code>List[str]</code>, optional<code>, None</code></dt>
<dd>if set, only the tags listet in this</dd>
</dl>
<p>parameter are returned</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>pandas dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_pre_and_num(self,
                      use_period: bool = True,
                      use_previous_period: bool = False,
                      tags: Optional[List[str]] = None,
                      ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    merges the raw data of pre and num together.
    depending on the parameters, it just uses the  period date and the previouis period date.
    furthermore, also the tags could be restricted.

    Note: default for use_period is True

    Args:
        use_period (bool, True): indicates that only the values are filtered which
        ddates machtes the period of the report.

        use_previous_period (bool, False): indicates that only the values  are filtered
        which ddates matches the period of the report and the previous year. If this is set
        to True, then the value of use_period is ignored

        tags (List[str], optional, None): if set, only the tags listet in this
        parameter are returned
    Returns:
        pd.DataFrame: pandas dataframe

    &#34;&#34;&#34;
    self._read_raw_data()  # lazy load the data if necessary
    num_df_filtered_for_dates = self.num_df

    ## only consider the entries in num.df that have ddates according to the set
    ## use_report and use_previoius_report

    # if use_previous_report, then use_period is ignored
    if use_period and not use_previous_period:
        mask = self.num_df[&#39;adsh&#39;].map(self.adsh_period_map) == self.num_df[&#39;ddate&#39;]
        num_df_filtered_for_dates = num_df_filtered_for_dates[mask]

    if use_previous_period:
        mask = (self.num_df[&#39;adsh&#39;].map(self.adsh_period_map) == self.num_df[&#39;ddate&#39;]) | \
               (self.num_df[&#39;adsh&#39;].map(self.adsh_previous_map) == self.num_df[&#39;ddate&#39;])

        num_df_filtered_for_dates = num_df_filtered_for_dates[mask]

    ## only consider the entries in pre which tag names are defined in the tags parameter
    pre_filtered_for_tags = self.pre_df
    if tags:
        pre_filtered_for_tags = self.pre_df[self.pre_df.tag.isin(tags)]

    ## transform the data
    # merge num and pre together. only rows in num are considered for which entries in pre exist
    return pd.merge(num_df_filtered_for_dates,
                    pre_filtered_for_tags,
                    on=[&#39;adsh&#39;, &#39;tag&#39;, &#39;version&#39;]) # don&#39;t produce index_x and index_y columns</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="secfsdstools.e_read" href="index.html">secfsdstools.e_read</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="secfsdstools.e_read.basereportreading.match_group_iter" href="#secfsdstools.e_read.basereportreading.match_group_iter">match_group_iter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader" href="#secfsdstools.e_read.basereportreading.BaseReportReader">BaseReportReader</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_period" href="#secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_period">financial_statements_for_period</a></code></li>
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_period_and_previous_period" href="#secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_period_and_previous_period">financial_statements_for_period_and_previous_period</a></code></li>
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_tags" href="#secfsdstools.e_read.basereportreading.BaseReportReader.financial_statements_for_tags">financial_statements_for_tags</a></code></li>
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_num_data" href="#secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_num_data">get_raw_num_data</a></code></li>
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_pre_data" href="#secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_pre_data">get_raw_pre_data</a></code></li>
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_sub_data" href="#secfsdstools.e_read.basereportreading.BaseReportReader.get_raw_sub_data">get_raw_sub_data</a></code></li>
<li><code><a title="secfsdstools.e_read.basereportreading.BaseReportReader.merge_pre_and_num" href="#secfsdstools.e_read.basereportreading.BaseReportReader.merge_pre_and_num">merge_pre_and_num</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>