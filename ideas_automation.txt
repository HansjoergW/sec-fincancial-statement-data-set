Fragen:
- standard Framework verwenden, dass auch bereits parallelisierung beherrscht? -> Nein
- Alle Prozessschritte in Pipelines umwandeln, oder kann download z.B. belassen wie es ist? -> Ja
- Wie mit quarterly und daily umgehen? -> Im Moment wie gehabt

- Wie wird der Status gemanaged? Immer über Files, oder doch besser über eine Tabelle?
  -> Vorteil File -> der Ist Zustand ist immer korrekt
  -> Vorteil Status in Tabelle -> Abfrage ist immer identisch
- Wie machen wir das ganze robust / Fehlerbehandlung
  -> Wie wird geprüft, ob ein Schritt für einen Teil tatsächlich ausgeführt wurde
     -> Z.B. welche Files müssen vorhanden sein.
- Steps eines Tasks
  - calculate_tasks -> bestimmen, für welche Teile (zip-files) Tasks überhaupt erstellt werden muss
  - pro Task
    - prepare -> Verzeichnis estellen/vorhandenes löschen
    - do -> Schritt ausführen
    - commit -> irgendwie bestätigen, dass Task vollendet ist
    - finish (z.B. entfernen von zip files -> müsste aber im Transform gemacht werden
    - exception -> cleanup

- Performance Optimierung ist nicht wirklich das Thema, da die Logik nur einmal pro Quartal läuft

Schritte

- einfachste Variante:
  -> eine simple Hook Methode
- kleines Framework

- Hinzufügen von customer Schritten

Umbau von CheckForNewData
- müsste eigentlich im init-py vom Root Modul gemacht werden, so dass diese Logik immer läuft
  - dort könnte man einfach getconfiguration callen und dann den check ausführen
  - Vorteil -> check wird immer gemacht
  - Nachteil: wenn das aber so gemacht wird, dann ist die Frage, wie eigene Tasks registriert werden können.
              das wäre dann eigentlich immer zu spät, ausser man macht das über das setup py
              oder wir managen eigene Tasks separat -> eigenr check, ob sie ausgeführt werden müssen, oder nicht

    def call_function_from_string(module_function_str):

        try:
            module_str, function_str = module_function_str.rsplit('.', 1)
            module = importlib.import_module(module_str)
            function = getattr(module, function_str)
            return function()
        except ModuleNotFoundError:
            print(f"Module {module_str} not found.")
        except AttributeError:
            print(f"Function {function_str} not found in module {module_str}.")
- configparser.ConfigParser ist teil von Configuration, falls configfile geladen wurde
  -> müsste als Parameter bei der callback funktion übergeben werden.

Struktur
--------
  _1_1_filtered_raw
     quarter
       2009q2.zip
       ...
     all   -> memory intensiv

  _1_2_filtered_joined
     quarter
       2009q2.zip
       ...
     all   -> memory intensiv

  _1_3_filtered_by_stmt_joined
     quarter
       2009q2.zip
          BS
          IS
          CF
          ...
       ...

     all_by_stmt
       BS
       IS
       CF
       ...

     all

  _2_standardize
    quarter
      2009q2.zip
         BS
         IS
         CF
      ...

    all
       BS
       IS
       CF




 open
    standardisieren könnte man direkt über all oder zuerst über die einzelnen quarter machen
    data/standardized/quarter/
        <zipname>/BS
                 /IS
                 /CF
        all      /BS
                 /IS
                 /CF

        allcombined

    data/standardizedcombined

    Ticker symbols
    outstanding shares / EPS_calc




