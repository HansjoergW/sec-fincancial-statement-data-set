<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>secfsdstools.f_standardize.bs_standardize API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>secfsdstools.f_standardize.bs_standardize</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
from abc import abstractmethod
from typing import List, Optional, Set

import numpy as np
import pandas as pd
import pandera as pa


class RuleEntity(ABC):

    @abstractmethod
    def get_input_tags(self) -&gt; Set[str]:
        pass

    def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
        pass


class Rule(RuleEntity):

    @abstractmethod
    def get_target_tag(self) -&gt; str:
        pass

    @abstractmethod
    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        pass

    @abstractmethod
    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        pass

    def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
        mask = self.mask(df)
        self.apply(df, mask)
        if (log_df is not None) and (len(log_df) == len(mask)):
            log_df[f&#34;{id}_{self.get_target_tag()}&#34;] = False
            log_df.loc[mask, f&#34;{id}_{self.get_target_tag()}&#34;] = True


class RuleGroup(RuleEntity):
    &#34;&#34;&#34;
    todo: to add -&gt; automatische vergabe von Rule ID bezüglich Gruppe
    ist das noch notwendig?
    Alle Regeln müssten eigentlich vom selben Typ sein
    Müsste man also auf den konkreten Rule Typ typisieren.
    ist das so?
    &#34;&#34;&#34;

    def __init__(self, rules: List[RuleEntity], prefix: str):
        self.rules = rules
        self.prefix = prefix

    def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
        for rule in self.rules:
            rule.process(df=df, log_df=log_df, id=id + self.prefix)

    def get_input_tags(self) -&gt; Set[str]:
        result: Set[str] = set()
        for rule in self.rules:
            result.update(rule.get_input_tags())
        return result


class RenameRule(Rule):

    def __init__(self, original: str, target: str):
        self.original = original
        self.target = target

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        return (df[self.target].isna() &amp;
                ~df[self.original].isna())

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.target] = df[self.original]

    def get_input_tags(self) -&gt; Set[str]:
        return {self.target, self.original}

    def get_target_tag(self) -&gt; str:
        return self.target


class MissingSumRule(Rule):
    &#34;&#34;&#34; creates the sum in the sum_name column if all summand_names columnes have a value&#34;&#34;&#34;

    def __init__(self, sum_name: str, summand_names: List[str]):
        self.sum_name = sum_name
        self.summand_names = summand_names

    def get_target_tag(self) -&gt; str:
        return self.sum_name

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name}
        result.update(self.summand_names)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum_name has to be not set and all summand_names have to be set
        mask = df[self.sum_name].isna()
        for summand_name in self.summand_names:
            mask = mask &amp; ~df[summand_name].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.sum_name] = df[self.summand_names].sum(axis=1)


class MissingSummandRule(Rule):

    def __init__(self, sum_name: str, missing_summand: str, existing_summands: List[str]):
        self.sum_name = sum_name
        self.missing_summand = missing_summand
        self.existing_summands = existing_summands

    def get_target_tag(self) -&gt; str:
        return self.missing_summand

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name, self.missing_summand}
        result.update(self.existing_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum and other_summands must be set, missing_summand must not be set
        mask = ~df[self.sum_name].isna()
        for summand_name in self.existing_summands:
            mask = mask &amp; ~df[summand_name].isna()
        mask = mask &amp; df[self.missing_summand].isna()
        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.missing_summand] = \
            df[self.sum_name] - df[self.existing_summands].sum(axis=1)


class SumCompletionRuleGroupCreator:
    &#34;&#34;&#34;
    completes the missing value of a simple addition, if one is missing.
    E.G Assets = AssetsCurrent + AssetsNoneCurrent
    &#34;&#34;&#34;

    @staticmethod
    def create_group(sum_tag: str, summand_tags: List[str], prefix: str) -&gt; RuleGroup:
        rules: List[RuleEntity] = [MissingSumRule(sum_name=sum_tag,
                                                  summand_names=summand_tags)]
        for summand in summand_tags:
            others = summand_tags.copy()
            others.remove(summand)
            rules.append(MissingSummandRule(sum_name=sum_tag, missing_summand=summand,
                                            existing_summands=others))
        return RuleGroup(rules=rules, prefix=prefix)


class SumUp(Rule):
    &#34;&#34;&#34;Sums app the available Summands to a new target column&#34;&#34;&#34;

    def __init__(self, target: str, potential_summands: List[str]):
        self.target = target
        self.potential_summands = potential_summands

    def get_target_tag(self) -&gt; str:
        return self.target

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.target}
        result.update(self.potential_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the target was not set..
        return df[self.target].isna()

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.target] = 0.0  # initialize
        for potential_summand in self.potential_summands:
            summand_mask = mask &amp; ~df[potential_summand].isna()
            df.loc[summand_mask, self.target] = df[self.target] + df[potential_summand]


class RuleProcessor:
    identifier_tags = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]

    def __init__(self, rule_tree: RuleGroup, post_rules: List[RuleEntity],
                 iterations: int, main_tags: List[str], final_tags: List[str],
                 filter_for_main_report: bool):
        self.rule_tree = rule_tree
        self.post_rules = post_rules
        self.iterations = iterations
        self.main_tags = main_tags
        self.final_tags = final_tags
        self.filter_for_main_report = filter_for_main_report

        self.final_col_order = self.identifier_tags + self.final_tags

        self.log_df: Optional[pd.DataFrame] = None
        self.stats: Optional[pd.DataFrame] = None


    def get_ruletree_descriptions(self):
        # todo
        pass

    def process(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        all_input_tags = self.rule_tree.get_input_tags()

        cpy_df = df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;uom&#39;, &#39;value&#39;, &#39;report&#39;, &#39;line&#39;,
                     &#39;negating&#39;]][df.tag.isin(all_input_tags)].copy()

        # todo: wann muss negating berücksichtigt werden -&gt; nach dem pivot fliegt es raus!

        # pivot the table, so that the tags are now columns
        # todo: folgende Zeile sollte nicht mehr notwendig sein, sobald alle Regeln implementiert sind
        expected_tags = all_input_tags.union(self.final_tags)
        pivot_df = self._pivot(df=cpy_df, expected_tags=expected_tags)

        if self.filter_for_main_report:
            pivot_df = self._filter_pivot_for_main_reports(pivot_df)

        self.log_df = pivot_df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]].copy()

        total_length = len(pivot_df)

        # calculate_pre_stats:
        pre_apply_df = pivot_df[self.final_col_order]
        self.pre_stats = self._calculate_stats(pivot_df=pre_apply_df)
        self.pre_stats.name = &#34;pre&#34;

        self.stats = pd.DataFrame(self.pre_stats)
        self.stats[&#39;pre_rel&#39;] = self.stats.pre / total_length

        self.stats = pd.DataFrame(self.pre_stats)

        for i in range(self.iterations):
            # apply the rule_tree
            self.rule_tree.process(df=pivot_df, log_df=self.log_df, id=f&#34;{i}_&#34;)

            self.post_stats = self._calculate_stats(pivot_df=pivot_df)
            self.post_stats.name = f&#34;post_{i}&#34;

            self.stats = self.stats.join(self.post_stats)
            self.stats[self.post_stats.name + &#39;_rel&#39;] = \
                self.stats[self.post_stats.name] / total_length
            self.stats[self.post_stats.name + &#39;_red&#39;] = \
                1 - (self.stats[self.post_stats.name] / self.stats.pre)

        # create a meaningful order
        pivot_df = pivot_df[self.final_col_order].copy()

        return pivot_df

    def _filter_pivot_for_main_reports(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Some reports have more than one &#39;report number&#39; (column report) for a
            certain statement. Generally, the one with the most tags is the one to take.
            This method operates on the pivoted data and counts the none-values of the
            &#34;main columns&#34;. The main columns are the fields, that generally should be there.
             &#34;&#34;&#34;

        cpy_pivot_df = pivot_df.copy()

        cpy_pivot_df[&#39;nan_count&#39;] = cpy_pivot_df[self.main_tags].isna().sum(axis=1)
        cpy_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;nan_count&#39;], inplace=True)
        cpy_pivot_df = cpy_pivot_df.groupby([&#39;adsh&#39;, &#39;coreg&#39;]).last()
        cpy_pivot_df.reset_index(inplace=True)
        return cpy_pivot_df

    def _calculate_stats(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        return pivot_df[self.final_tags].isna().sum(axis=0)

    def _pivot(self, df: pd.DataFrame, expected_tags: Set[str]) -&gt; pd.DataFrame:
        # todo: um pivot zu optimieren, sollten zuerst nur die Tags gefiltert werden,
        # welche tatsächlich auch benützt werden, alles andere sollte herausgefiltert werden
        # das müsste über die Regeln geschehen und sollte automatisch berechnet werden sollen.

        # it is possible, that the same number appears multiple times in different lines,
        # therefore, duplicates have to be removed, otherwise pivot is not possible
        relevant_df = df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;value&#39;, &#39;ddate&#39;]].drop_duplicates()

        duplicates_df = relevant_df[
            [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;ddate&#39;]].value_counts().reset_index()
        duplicates_df.rename(columns={0: &#39;count&#39;}, inplace=True)
        duplicated_adsh = duplicates_df[duplicates_df[&#39;count&#39;] &gt; 1].adsh.unique().tolist()

        # todo: logging duplicated entries ...&gt;
        relevant_df = relevant_df[~relevant_df.adsh.isin(duplicated_adsh)]

        pivot_df = relevant_df.pivot(index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;],
                                     columns=&#39;tag&#39;,
                                     values=&#39;value&#39;)
        pivot_df.reset_index(inplace=True)
        missing_cols = set(expected_tags) - set(pivot_df.columns)
        for missing_col in missing_cols:
            pivot_df[missing_col] = np.nan
        pivot_df[&#39;nan_count&#39;] = np.nan
        return pivot_df


class BalanceSheetStandardizer(RuleProcessor):
    &#34;&#34;&#34;wichtig, nur für main optimiert, nicht für coregs&#34;&#34;&#34;

    bs_rename_rg = RuleGroup(
        rules=[
            RenameRule(original=&#39;AssetsNet&#39;, target=&#39;Assets&#39;),
            RenameRule(
                original=&#39;StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest&#39;,
                target=&#39;Equity&#39;),
            RenameRule(original=&#39;PartnersCapital&#39;, target=&#39;Equity&#39;),
            RenameRule(original=&#39;StockholdersEquity&#39;, target=&#39;Equity&#39;),
            RenameRule(original=&#39;CashAndCashEquivalentsAtCarryingValue&#39;, target=&#39;Cash&#39;),
            RenameRule(original=&#39;RetainedEarningsAppropriated&#39;, target=&#39;RetainedEarnings&#39;),
            RenameRule(original=&#39;RetainedEarningsAccumulatedDeficit&#39;, target=&#39;RetainedEarnings&#39;)
        ],
        prefix=&#34;BR&#34;
    )

    # todo: CashOther wird noch nirgends verwendet
    bs_sumup_rg = RuleGroup(
        rules=[SumUp(
            target=&#39;CashOther&#39;,
            potential_summands=[
                &#39;CashAndCashEquivalentsAtFairValue&#39;,
                &#39;CashAndDueFromBanks&#39;,
                &#39;CashCashEquivalentsAndFederalFundsSold&#39;,
                &#39;RestrictedCashAndCashEquivalentsAtCarryingValue&#39;,
                &#39;CashAndCashEquivalentsInForeignCurrencyAtCarryingValue&#39;])],
        prefix=&#34;SU&#34;
    )

    bs_sum_completion = RuleGroup(
        prefix=&#34;SC&#34;,
        rules=[
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Assets&#39;,
                summand_tags=[&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;],
                prefix=&#34;Ass&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Liabilities&#39;,
                summand_tags=[&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;],
                prefix=&#34;Lia&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Assets&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;Equity&#39;],
                prefix=&#34;Ass2&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;LiabilitiesAndStockholdersEquity&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;Equity&#39;],
                prefix=&#34;LiaEq&#34;
            )
        ])

    rule_tree = RuleGroup(prefix=&#34;BS_&#34;,
                               rules=[
                                   bs_rename_rg,
                                   bs_sumup_rg,
                                   bs_sum_completion,
                               ])

    # these are the columns that finally are returned after the standardization
    final_tags: List[str] = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                             &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;,
                             &#39;Equity&#39;,
                             &#39;InventoryNet&#39;,
                             &#39;Cash&#39;,
                             &#39;CashOther&#39;,
                             &#39;RetainedEarnings&#39;
                             ]

    # used to evaluate if a report is a the main balancesheet report
    # inside a report, there can be several different tables (different report nr)
    # which stmt value is BS.
    # however, we might be only interested in the &#34;major&#34; BS report. Usually this is the
    # one which has the least nan in the following columns
    main_tags = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                    &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;]

    def __init__(self, filter_for_main_report: bool = False, iterations: int = 2):
        super().__init__(rule_tree=self.rule_tree, post_rules=[], iterations=iterations,
                         main_tags=self.main_tags, final_tags=self.final_tags,
                         filter_for_main_report=filter_for_main_report)




# there are pre-pivot and post-pivot rules ..
# in order to make a pre assesement on how many fields could be filled, we would need to have
# pivot run without applying any rules, just pivot and return the desired colums,
# or just the basic renaming ...
# but without going for changing default names

# man könnte noch checks einbauen, ob z.B. die Summen definition gültig sind,
# d.h., dass der Wert der Summe in etwa der Summe der Werte der Summanden entsprciht


class BalanceSheetStandardizerOld:

    def fill_still_isna_summands(self, df: pd.DataFrame):
        &#34;&#34;&#34; if we are left with unset summands&#34;&#34;&#34;

        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        for total, summands in BalanceSheetStandardizerOld.sum_definition.items():
            summand_1 = summands[0]
            summand_2 = summands[1]

            # if only the total is present, we assume that only the first summand (eg. currentassets are present)
            # that is not really proper.
            mask_total_nosum1_nosum2 = (~df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_total_nosum1_nosum2, summand_1] = df[total]
            df.loc[mask_total_nosum1_nosum2, summand_2] = 0.0

            # if only the first summand is present, wie assume that the total is equal to the first summand
            # and that the second summand is 0
            mask_nototal_sum1_nosum2 = (df[total].isna() &amp;
                                        ~df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_nototal_sum1_nosum2, total] = df[summand_1]
            df.loc[mask_nototal_sum1_nosum2, summand_2] = 0.0

            # if only the second summand is present, wie assume that the total is equal to the second summand
            # and that the first  summand is 0
            mask_nototal_nosum1_sum2 = (df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        ~df[summand_2].isna())
            df.loc[mask_nototal_nosum1_sum2, total] = df[summand_2]
            df.loc[mask_nototal_nosum1_sum2, summand_1] = 0.0

    def complete_special_rules(self, df: pd.DataFrame):
        &#34;&#34;&#34;
        Special rules which help to complete the information
        &#34;&#34;&#34;

        # self._basic_sum_completion(df, total=&#39;Assets&#39;, summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)
        #
        # # actually, LiabilitiesAndStockholdersEquity should have the same value as Assets
        # self._basic_sum_completion(df, total=&#39;LiabilitiesAndStockholdersEquity&#39;,
        #                            summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)

        # run complete sum again, since total fields could be present now
        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        self.complete_sums(df)

        self.fill_still_isna_summands(df)

        # if Equity == -Liabilities and Assets is nan, then
        # Assets, AssetsCurrent, and AssetsNoncurrent is 0.0
        mask = (df.Equity == -df.Liabilities) &amp; df.Assets.isna()
        df.loc[mask, &#39;Assets&#39;] = 0.0
        df.loc[mask, &#39;AssetsCurrent&#39;] = 0.0
        df.loc[mask, &#39;AssetsNoncurrent&#39;] = 0.0

        # if Cash is not set, then use CashOther to set Cash
        mask = df.Cash.isna()
        df.loc[mask, &#39;Cash&#39;] = df.CashOther

        # set to zero
        mask = df.InventoryNet.isna()
        df.loc[mask, &#39;InventoryNet&#39;] = 0.0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer"><code class="flex name class">
<span>class <span class="ident">BalanceSheetStandardizer</span></span>
<span>(</span><span>filter_for_main_report: bool = False, iterations: int = 2)</span>
</code></dt>
<dd>
<div class="desc"><p>wichtig, nur für main optimiert, nicht für coregs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceSheetStandardizer(RuleProcessor):
    &#34;&#34;&#34;wichtig, nur für main optimiert, nicht für coregs&#34;&#34;&#34;

    bs_rename_rg = RuleGroup(
        rules=[
            RenameRule(original=&#39;AssetsNet&#39;, target=&#39;Assets&#39;),
            RenameRule(
                original=&#39;StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest&#39;,
                target=&#39;Equity&#39;),
            RenameRule(original=&#39;PartnersCapital&#39;, target=&#39;Equity&#39;),
            RenameRule(original=&#39;StockholdersEquity&#39;, target=&#39;Equity&#39;),
            RenameRule(original=&#39;CashAndCashEquivalentsAtCarryingValue&#39;, target=&#39;Cash&#39;),
            RenameRule(original=&#39;RetainedEarningsAppropriated&#39;, target=&#39;RetainedEarnings&#39;),
            RenameRule(original=&#39;RetainedEarningsAccumulatedDeficit&#39;, target=&#39;RetainedEarnings&#39;)
        ],
        prefix=&#34;BR&#34;
    )

    # todo: CashOther wird noch nirgends verwendet
    bs_sumup_rg = RuleGroup(
        rules=[SumUp(
            target=&#39;CashOther&#39;,
            potential_summands=[
                &#39;CashAndCashEquivalentsAtFairValue&#39;,
                &#39;CashAndDueFromBanks&#39;,
                &#39;CashCashEquivalentsAndFederalFundsSold&#39;,
                &#39;RestrictedCashAndCashEquivalentsAtCarryingValue&#39;,
                &#39;CashAndCashEquivalentsInForeignCurrencyAtCarryingValue&#39;])],
        prefix=&#34;SU&#34;
    )

    bs_sum_completion = RuleGroup(
        prefix=&#34;SC&#34;,
        rules=[
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Assets&#39;,
                summand_tags=[&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;],
                prefix=&#34;Ass&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Liabilities&#39;,
                summand_tags=[&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;],
                prefix=&#34;Lia&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Assets&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;Equity&#39;],
                prefix=&#34;Ass2&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;LiabilitiesAndStockholdersEquity&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;Equity&#39;],
                prefix=&#34;LiaEq&#34;
            )
        ])

    rule_tree = RuleGroup(prefix=&#34;BS_&#34;,
                               rules=[
                                   bs_rename_rg,
                                   bs_sumup_rg,
                                   bs_sum_completion,
                               ])

    # these are the columns that finally are returned after the standardization
    final_tags: List[str] = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                             &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;,
                             &#39;Equity&#39;,
                             &#39;InventoryNet&#39;,
                             &#39;Cash&#39;,
                             &#39;CashOther&#39;,
                             &#39;RetainedEarnings&#39;
                             ]

    # used to evaluate if a report is a the main balancesheet report
    # inside a report, there can be several different tables (different report nr)
    # which stmt value is BS.
    # however, we might be only interested in the &#34;major&#34; BS report. Usually this is the
    # one which has the least nan in the following columns
    main_tags = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                    &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;]

    def __init__(self, filter_for_main_report: bool = False, iterations: int = 2):
        super().__init__(rule_tree=self.rule_tree, post_rules=[], iterations=iterations,
                         main_tags=self.main_tags, final_tags=self.final_tags,
                         filter_for_main_report=filter_for_main_report)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor">RuleProcessor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_rename_rg"><code class="name">var <span class="ident">bs_rename_rg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sum_completion"><code class="name">var <span class="ident">bs_sum_completion</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sumup_rg"><code class="name">var <span class="ident">bs_sumup_rg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.final_tags"><code class="name">var <span class="ident">final_tags</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.main_tags"><code class="name">var <span class="ident">main_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.rule_tree"><code class="name">var <span class="ident">rule_tree</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld"><code class="flex name class">
<span>class <span class="ident">BalanceSheetStandardizerOld</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceSheetStandardizerOld:

    def fill_still_isna_summands(self, df: pd.DataFrame):
        &#34;&#34;&#34; if we are left with unset summands&#34;&#34;&#34;

        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        for total, summands in BalanceSheetStandardizerOld.sum_definition.items():
            summand_1 = summands[0]
            summand_2 = summands[1]

            # if only the total is present, we assume that only the first summand (eg. currentassets are present)
            # that is not really proper.
            mask_total_nosum1_nosum2 = (~df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_total_nosum1_nosum2, summand_1] = df[total]
            df.loc[mask_total_nosum1_nosum2, summand_2] = 0.0

            # if only the first summand is present, wie assume that the total is equal to the first summand
            # and that the second summand is 0
            mask_nototal_sum1_nosum2 = (df[total].isna() &amp;
                                        ~df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_nototal_sum1_nosum2, total] = df[summand_1]
            df.loc[mask_nototal_sum1_nosum2, summand_2] = 0.0

            # if only the second summand is present, wie assume that the total is equal to the second summand
            # and that the first  summand is 0
            mask_nototal_nosum1_sum2 = (df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        ~df[summand_2].isna())
            df.loc[mask_nototal_nosum1_sum2, total] = df[summand_2]
            df.loc[mask_nototal_nosum1_sum2, summand_1] = 0.0

    def complete_special_rules(self, df: pd.DataFrame):
        &#34;&#34;&#34;
        Special rules which help to complete the information
        &#34;&#34;&#34;

        # self._basic_sum_completion(df, total=&#39;Assets&#39;, summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)
        #
        # # actually, LiabilitiesAndStockholdersEquity should have the same value as Assets
        # self._basic_sum_completion(df, total=&#39;LiabilitiesAndStockholdersEquity&#39;,
        #                            summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)

        # run complete sum again, since total fields could be present now
        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        self.complete_sums(df)

        self.fill_still_isna_summands(df)

        # if Equity == -Liabilities and Assets is nan, then
        # Assets, AssetsCurrent, and AssetsNoncurrent is 0.0
        mask = (df.Equity == -df.Liabilities) &amp; df.Assets.isna()
        df.loc[mask, &#39;Assets&#39;] = 0.0
        df.loc[mask, &#39;AssetsCurrent&#39;] = 0.0
        df.loc[mask, &#39;AssetsNoncurrent&#39;] = 0.0

        # if Cash is not set, then use CashOther to set Cash
        mask = df.Cash.isna()
        df.loc[mask, &#39;Cash&#39;] = df.CashOther

        # set to zero
        mask = df.InventoryNet.isna()
        df.loc[mask, &#39;InventoryNet&#39;] = 0.0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.complete_special_rules"><code class="name flex">
<span>def <span class="ident">complete_special_rules</span></span>(<span>self, df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Special rules which help to complete the information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_special_rules(self, df: pd.DataFrame):
    &#34;&#34;&#34;
    Special rules which help to complete the information
    &#34;&#34;&#34;

    # self._basic_sum_completion(df, total=&#39;Assets&#39;, summand_1=&#39;Liabilities&#39;,
    #                            summand_2=&#39;Equity&#39;)
    #
    # # actually, LiabilitiesAndStockholdersEquity should have the same value as Assets
    # self._basic_sum_completion(df, total=&#39;LiabilitiesAndStockholdersEquity&#39;,
    #                            summand_1=&#39;Liabilities&#39;,
    #                            summand_2=&#39;Equity&#39;)

    # run complete sum again, since total fields could be present now
    # for:
    # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
    # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
    self.complete_sums(df)

    self.fill_still_isna_summands(df)

    # if Equity == -Liabilities and Assets is nan, then
    # Assets, AssetsCurrent, and AssetsNoncurrent is 0.0
    mask = (df.Equity == -df.Liabilities) &amp; df.Assets.isna()
    df.loc[mask, &#39;Assets&#39;] = 0.0
    df.loc[mask, &#39;AssetsCurrent&#39;] = 0.0
    df.loc[mask, &#39;AssetsNoncurrent&#39;] = 0.0

    # if Cash is not set, then use CashOther to set Cash
    mask = df.Cash.isna()
    df.loc[mask, &#39;Cash&#39;] = df.CashOther

    # set to zero
    mask = df.InventoryNet.isna()
    df.loc[mask, &#39;InventoryNet&#39;] = 0.0</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.fill_still_isna_summands"><code class="name flex">
<span>def <span class="ident">fill_still_isna_summands</span></span>(<span>self, df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>if we are left with unset summands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_still_isna_summands(self, df: pd.DataFrame):
    &#34;&#34;&#34; if we are left with unset summands&#34;&#34;&#34;

    # for:
    # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
    # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
    for total, summands in BalanceSheetStandardizerOld.sum_definition.items():
        summand_1 = summands[0]
        summand_2 = summands[1]

        # if only the total is present, we assume that only the first summand (eg. currentassets are present)
        # that is not really proper.
        mask_total_nosum1_nosum2 = (~df[total].isna() &amp;
                                    df[summand_1].isna() &amp;
                                    df[summand_2].isna())
        df.loc[mask_total_nosum1_nosum2, summand_1] = df[total]
        df.loc[mask_total_nosum1_nosum2, summand_2] = 0.0

        # if only the first summand is present, wie assume that the total is equal to the first summand
        # and that the second summand is 0
        mask_nototal_sum1_nosum2 = (df[total].isna() &amp;
                                    ~df[summand_1].isna() &amp;
                                    df[summand_2].isna())
        df.loc[mask_nototal_sum1_nosum2, total] = df[summand_1]
        df.loc[mask_nototal_sum1_nosum2, summand_2] = 0.0

        # if only the second summand is present, wie assume that the total is equal to the second summand
        # and that the first  summand is 0
        mask_nototal_nosum1_sum2 = (df[total].isna() &amp;
                                    df[summand_1].isna() &amp;
                                    ~df[summand_2].isna())
        df.loc[mask_nototal_nosum1_sum2, total] = df[summand_2]
        df.loc[mask_nototal_nosum1_sum2, summand_1] = 0.0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule"><code class="flex name class">
<span>class <span class="ident">MissingSumRule</span></span>
<span>(</span><span>sum_name: str, summand_names: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>creates the sum in the sum_name column if all summand_names columnes have a value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingSumRule(Rule):
    &#34;&#34;&#34; creates the sum in the sum_name column if all summand_names columnes have a value&#34;&#34;&#34;

    def __init__(self, sum_name: str, summand_names: List[str]):
        self.sum_name = sum_name
        self.summand_names = summand_names

    def get_target_tag(self) -&gt; str:
        return self.sum_name

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name}
        result.update(self.summand_names)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum_name has to be not set and all summand_names have to be set
        mask = df[self.sum_name].isna()
        for summand_name in self.summand_names:
            mask = mask &amp; ~df[summand_name].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.sum_name] = df[self.summand_names].sum(axis=1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.Rule" href="#secfsdstools.f_standardize.bs_standardize.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
    df.loc[mask, self.sum_name] = df[self.summand_names].sum(axis=1)</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule.get_input_tags"><code class="name flex">
<span>def <span class="ident">get_input_tags</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_tags(self) -&gt; Set[str]:
    result = {self.sum_name}
    result.update(self.summand_names)
    return result</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule.get_target_tag"><code class="name flex">
<span>def <span class="ident">get_target_tag</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_target_tag(self) -&gt; str:
    return self.sum_name</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    # sum_name has to be not set and all summand_names have to be set
    mask = df[self.sum_name].isna()
    for summand_name in self.summand_names:
        mask = mask &amp; ~df[summand_name].isna()

    return mask</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule"><code class="flex name class">
<span>class <span class="ident">MissingSummandRule</span></span>
<span>(</span><span>sum_name: str, missing_summand: str, existing_summands: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingSummandRule(Rule):

    def __init__(self, sum_name: str, missing_summand: str, existing_summands: List[str]):
        self.sum_name = sum_name
        self.missing_summand = missing_summand
        self.existing_summands = existing_summands

    def get_target_tag(self) -&gt; str:
        return self.missing_summand

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name, self.missing_summand}
        result.update(self.existing_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum and other_summands must be set, missing_summand must not be set
        mask = ~df[self.sum_name].isna()
        for summand_name in self.existing_summands:
            mask = mask &amp; ~df[summand_name].isna()
        mask = mask &amp; df[self.missing_summand].isna()
        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.missing_summand] = \
            df[self.sum_name] - df[self.existing_summands].sum(axis=1)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.Rule" href="#secfsdstools.f_standardize.bs_standardize.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
    df.loc[mask, self.missing_summand] = \
        df[self.sum_name] - df[self.existing_summands].sum(axis=1)</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.get_input_tags"><code class="name flex">
<span>def <span class="ident">get_input_tags</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_tags(self) -&gt; Set[str]:
    result = {self.sum_name, self.missing_summand}
    result.update(self.existing_summands)
    return result</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.get_target_tag"><code class="name flex">
<span>def <span class="ident">get_target_tag</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_target_tag(self) -&gt; str:
    return self.missing_summand</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    # sum and other_summands must be set, missing_summand must not be set
    mask = ~df[self.sum_name].isna()
    for summand_name in self.existing_summands:
        mask = mask &amp; ~df[summand_name].isna()
    mask = mask &amp; df[self.missing_summand].isna()
    return mask</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RenameRule"><code class="flex name class">
<span>class <span class="ident">RenameRule</span></span>
<span>(</span><span>original: str, target: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RenameRule(Rule):

    def __init__(self, original: str, target: str):
        self.original = original
        self.target = target

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        return (df[self.target].isna() &amp;
                ~df[self.original].isna())

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.target] = df[self.original]

    def get_input_tags(self) -&gt; Set[str]:
        return {self.target, self.original}

    def get_target_tag(self) -&gt; str:
        return self.target</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.Rule" href="#secfsdstools.f_standardize.bs_standardize.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RenameRule.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
    df.loc[mask, self.target] = df[self.original]</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RenameRule.get_input_tags"><code class="name flex">
<span>def <span class="ident">get_input_tags</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_tags(self) -&gt; Set[str]:
    return {self.target, self.original}</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RenameRule.get_target_tag"><code class="name flex">
<span>def <span class="ident">get_target_tag</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_target_tag(self) -&gt; str:
    return self.target</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RenameRule.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    return (df[self.target].isna() &amp;
            ~df[self.original].isna())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.Rule"><code class="flex name class">
<span>class <span class="ident">Rule</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rule(RuleEntity):

    @abstractmethod
    def get_target_tag(self) -&gt; str:
        pass

    @abstractmethod
    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        pass

    @abstractmethod
    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        pass

    def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
        mask = self.mask(df)
        self.apply(df, mask)
        if (log_df is not None) and (len(log_df) == len(mask)):
            log_df[f&#34;{id}_{self.get_target_tag()}&#34;] = False
            log_df.loc[mask, f&#34;{id}_{self.get_target_tag()}&#34;] = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule">MissingSumRule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule">MissingSummandRule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.RenameRule" href="#secfsdstools.f_standardize.bs_standardize.RenameRule">RenameRule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.SumUp" href="#secfsdstools.f_standardize.bs_standardize.SumUp">SumUp</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.Rule.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.Rule.get_target_tag"><code class="name flex">
<span>def <span class="ident">get_target_tag</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_target_tag(self) -&gt; str:
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.Rule.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.Rule.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, df: pandas.core.frame.DataFrame, log_df: Optional[pandas.core.frame.DataFrame] = None, id: str = '')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
    mask = self.mask(df)
    self.apply(df, mask)
    if (log_df is not None) and (len(log_df) == len(mask)):
        log_df[f&#34;{id}_{self.get_target_tag()}&#34;] = False
        log_df.loc[mask, f&#34;{id}_{self.get_target_tag()}&#34;] = True</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleEntity"><code class="flex name class">
<span>class <span class="ident">RuleEntity</span></span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleEntity(ABC):

    @abstractmethod
    def get_input_tags(self) -&gt; Set[str]:
        pass

    def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.Rule" href="#secfsdstools.f_standardize.bs_standardize.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleGroup" href="#secfsdstools.f_standardize.bs_standardize.RuleGroup">RuleGroup</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleEntity.get_input_tags"><code class="name flex">
<span>def <span class="ident">get_input_tags</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def get_input_tags(self) -&gt; Set[str]:
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleEntity.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, df: pandas.core.frame.DataFrame, log_df: Optional[pandas.core.frame.DataFrame] = None, id: str = '')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleGroup"><code class="flex name class">
<span>class <span class="ident">RuleGroup</span></span>
<span>(</span><span>rules: List[<a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a>], prefix: str)</span>
</code></dt>
<dd>
<div class="desc"><p>todo: to add -&gt; automatische vergabe von Rule ID bezüglich Gruppe
ist das noch notwendig?
Alle Regeln müssten eigentlich vom selben Typ sein
Müsste man also auf den konkreten Rule Typ typisieren.
ist das so?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleGroup(RuleEntity):
    &#34;&#34;&#34;
    todo: to add -&gt; automatische vergabe von Rule ID bezüglich Gruppe
    ist das noch notwendig?
    Alle Regeln müssten eigentlich vom selben Typ sein
    Müsste man also auf den konkreten Rule Typ typisieren.
    ist das so?
    &#34;&#34;&#34;

    def __init__(self, rules: List[RuleEntity], prefix: str):
        self.rules = rules
        self.prefix = prefix

    def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
        for rule in self.rules:
            rule.process(df=df, log_df=log_df, id=id + self.prefix)

    def get_input_tags(self) -&gt; Set[str]:
        result: Set[str] = set()
        for rule in self.rules:
            result.update(rule.get_input_tags())
        return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleGroup.get_input_tags"><code class="name flex">
<span>def <span class="ident">get_input_tags</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_tags(self) -&gt; Set[str]:
    result: Set[str] = set()
    for rule in self.rules:
        result.update(rule.get_input_tags())
    return result</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleGroup.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, df: pandas.core.frame.DataFrame, log_df: Optional[pandas.core.frame.DataFrame] = None, id: str = '')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, df: pd.DataFrame, log_df: Optional[pd.DataFrame] = None, id: str = &#34;&#34;):
    for rule in self.rules:
        rule.process(df=df, log_df=log_df, id=id + self.prefix)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor"><code class="flex name class">
<span>class <span class="ident">RuleProcessor</span></span>
<span>(</span><span>rule_tree: <a title="secfsdstools.f_standardize.bs_standardize.RuleGroup" href="#secfsdstools.f_standardize.bs_standardize.RuleGroup">RuleGroup</a>, post_rules: List[<a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a>], iterations: int, main_tags: List[str], final_tags: List[str], filter_for_main_report: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleProcessor:
    identifier_tags = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]

    def __init__(self, rule_tree: RuleGroup, post_rules: List[RuleEntity],
                 iterations: int, main_tags: List[str], final_tags: List[str],
                 filter_for_main_report: bool):
        self.rule_tree = rule_tree
        self.post_rules = post_rules
        self.iterations = iterations
        self.main_tags = main_tags
        self.final_tags = final_tags
        self.filter_for_main_report = filter_for_main_report

        self.final_col_order = self.identifier_tags + self.final_tags

        self.log_df: Optional[pd.DataFrame] = None
        self.stats: Optional[pd.DataFrame] = None


    def get_ruletree_descriptions(self):
        # todo
        pass

    def process(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        all_input_tags = self.rule_tree.get_input_tags()

        cpy_df = df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;uom&#39;, &#39;value&#39;, &#39;report&#39;, &#39;line&#39;,
                     &#39;negating&#39;]][df.tag.isin(all_input_tags)].copy()

        # todo: wann muss negating berücksichtigt werden -&gt; nach dem pivot fliegt es raus!

        # pivot the table, so that the tags are now columns
        # todo: folgende Zeile sollte nicht mehr notwendig sein, sobald alle Regeln implementiert sind
        expected_tags = all_input_tags.union(self.final_tags)
        pivot_df = self._pivot(df=cpy_df, expected_tags=expected_tags)

        if self.filter_for_main_report:
            pivot_df = self._filter_pivot_for_main_reports(pivot_df)

        self.log_df = pivot_df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]].copy()

        total_length = len(pivot_df)

        # calculate_pre_stats:
        pre_apply_df = pivot_df[self.final_col_order]
        self.pre_stats = self._calculate_stats(pivot_df=pre_apply_df)
        self.pre_stats.name = &#34;pre&#34;

        self.stats = pd.DataFrame(self.pre_stats)
        self.stats[&#39;pre_rel&#39;] = self.stats.pre / total_length

        self.stats = pd.DataFrame(self.pre_stats)

        for i in range(self.iterations):
            # apply the rule_tree
            self.rule_tree.process(df=pivot_df, log_df=self.log_df, id=f&#34;{i}_&#34;)

            self.post_stats = self._calculate_stats(pivot_df=pivot_df)
            self.post_stats.name = f&#34;post_{i}&#34;

            self.stats = self.stats.join(self.post_stats)
            self.stats[self.post_stats.name + &#39;_rel&#39;] = \
                self.stats[self.post_stats.name] / total_length
            self.stats[self.post_stats.name + &#39;_red&#39;] = \
                1 - (self.stats[self.post_stats.name] / self.stats.pre)

        # create a meaningful order
        pivot_df = pivot_df[self.final_col_order].copy()

        return pivot_df

    def _filter_pivot_for_main_reports(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Some reports have more than one &#39;report number&#39; (column report) for a
            certain statement. Generally, the one with the most tags is the one to take.
            This method operates on the pivoted data and counts the none-values of the
            &#34;main columns&#34;. The main columns are the fields, that generally should be there.
             &#34;&#34;&#34;

        cpy_pivot_df = pivot_df.copy()

        cpy_pivot_df[&#39;nan_count&#39;] = cpy_pivot_df[self.main_tags].isna().sum(axis=1)
        cpy_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;nan_count&#39;], inplace=True)
        cpy_pivot_df = cpy_pivot_df.groupby([&#39;adsh&#39;, &#39;coreg&#39;]).last()
        cpy_pivot_df.reset_index(inplace=True)
        return cpy_pivot_df

    def _calculate_stats(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        return pivot_df[self.final_tags].isna().sum(axis=0)

    def _pivot(self, df: pd.DataFrame, expected_tags: Set[str]) -&gt; pd.DataFrame:
        # todo: um pivot zu optimieren, sollten zuerst nur die Tags gefiltert werden,
        # welche tatsächlich auch benützt werden, alles andere sollte herausgefiltert werden
        # das müsste über die Regeln geschehen und sollte automatisch berechnet werden sollen.

        # it is possible, that the same number appears multiple times in different lines,
        # therefore, duplicates have to be removed, otherwise pivot is not possible
        relevant_df = df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;value&#39;, &#39;ddate&#39;]].drop_duplicates()

        duplicates_df = relevant_df[
            [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;ddate&#39;]].value_counts().reset_index()
        duplicates_df.rename(columns={0: &#39;count&#39;}, inplace=True)
        duplicated_adsh = duplicates_df[duplicates_df[&#39;count&#39;] &gt; 1].adsh.unique().tolist()

        # todo: logging duplicated entries ...&gt;
        relevant_df = relevant_df[~relevant_df.adsh.isin(duplicated_adsh)]

        pivot_df = relevant_df.pivot(index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;],
                                     columns=&#39;tag&#39;,
                                     values=&#39;value&#39;)
        pivot_df.reset_index(inplace=True)
        missing_cols = set(expected_tags) - set(pivot_df.columns)
        for missing_col in missing_cols:
            pivot_df[missing_col] = np.nan
        pivot_df[&#39;nan_count&#39;] = np.nan
        return pivot_df</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer">BalanceSheetStandardizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor.identifier_tags"><code class="name">var <span class="ident">identifier_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor.get_ruletree_descriptions"><code class="name flex">
<span>def <span class="ident">get_ruletree_descriptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ruletree_descriptions(self):
    # todo
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, df: pd.DataFrame) -&gt; pd.DataFrame:
    all_input_tags = self.rule_tree.get_input_tags()

    cpy_df = df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;uom&#39;, &#39;value&#39;, &#39;report&#39;, &#39;line&#39;,
                 &#39;negating&#39;]][df.tag.isin(all_input_tags)].copy()

    # todo: wann muss negating berücksichtigt werden -&gt; nach dem pivot fliegt es raus!

    # pivot the table, so that the tags are now columns
    # todo: folgende Zeile sollte nicht mehr notwendig sein, sobald alle Regeln implementiert sind
    expected_tags = all_input_tags.union(self.final_tags)
    pivot_df = self._pivot(df=cpy_df, expected_tags=expected_tags)

    if self.filter_for_main_report:
        pivot_df = self._filter_pivot_for_main_reports(pivot_df)

    self.log_df = pivot_df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]].copy()

    total_length = len(pivot_df)

    # calculate_pre_stats:
    pre_apply_df = pivot_df[self.final_col_order]
    self.pre_stats = self._calculate_stats(pivot_df=pre_apply_df)
    self.pre_stats.name = &#34;pre&#34;

    self.stats = pd.DataFrame(self.pre_stats)
    self.stats[&#39;pre_rel&#39;] = self.stats.pre / total_length

    self.stats = pd.DataFrame(self.pre_stats)

    for i in range(self.iterations):
        # apply the rule_tree
        self.rule_tree.process(df=pivot_df, log_df=self.log_df, id=f&#34;{i}_&#34;)

        self.post_stats = self._calculate_stats(pivot_df=pivot_df)
        self.post_stats.name = f&#34;post_{i}&#34;

        self.stats = self.stats.join(self.post_stats)
        self.stats[self.post_stats.name + &#39;_rel&#39;] = \
            self.stats[self.post_stats.name] / total_length
        self.stats[self.post_stats.name + &#39;_red&#39;] = \
            1 - (self.stats[self.post_stats.name] / self.stats.pre)

    # create a meaningful order
    pivot_df = pivot_df[self.final_col_order].copy()

    return pivot_df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator"><code class="flex name class">
<span>class <span class="ident">SumCompletionRuleGroupCreator</span></span>
</code></dt>
<dd>
<div class="desc"><p>completes the missing value of a simple addition, if one is missing.
E.G Assets = AssetsCurrent + AssetsNoneCurrent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SumCompletionRuleGroupCreator:
    &#34;&#34;&#34;
    completes the missing value of a simple addition, if one is missing.
    E.G Assets = AssetsCurrent + AssetsNoneCurrent
    &#34;&#34;&#34;

    @staticmethod
    def create_group(sum_tag: str, summand_tags: List[str], prefix: str) -&gt; RuleGroup:
        rules: List[RuleEntity] = [MissingSumRule(sum_name=sum_tag,
                                                  summand_names=summand_tags)]
        for summand in summand_tags:
            others = summand_tags.copy()
            others.remove(summand)
            rules.append(MissingSummandRule(sum_name=sum_tag, missing_summand=summand,
                                            existing_summands=others))
        return RuleGroup(rules=rules, prefix=prefix)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator.create_group"><code class="name flex">
<span>def <span class="ident">create_group</span></span>(<span>sum_tag: str, summand_tags: List[str], prefix: str) ‑> <a title="secfsdstools.f_standardize.bs_standardize.RuleGroup" href="#secfsdstools.f_standardize.bs_standardize.RuleGroup">RuleGroup</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_group(sum_tag: str, summand_tags: List[str], prefix: str) -&gt; RuleGroup:
    rules: List[RuleEntity] = [MissingSumRule(sum_name=sum_tag,
                                              summand_names=summand_tags)]
    for summand in summand_tags:
        others = summand_tags.copy()
        others.remove(summand)
        rules.append(MissingSummandRule(sum_name=sum_tag, missing_summand=summand,
                                        existing_summands=others))
    return RuleGroup(rules=rules, prefix=prefix)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp"><code class="flex name class">
<span>class <span class="ident">SumUp</span></span>
<span>(</span><span>target: str, potential_summands: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Sums app the available Summands to a new target column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SumUp(Rule):
    &#34;&#34;&#34;Sums app the available Summands to a new target column&#34;&#34;&#34;

    def __init__(self, target: str, potential_summands: List[str]):
        self.target = target
        self.potential_summands = potential_summands

    def get_target_tag(self) -&gt; str:
        return self.target

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.target}
        result.update(self.potential_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the target was not set..
        return df[self.target].isna()

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.target] = 0.0  # initialize
        for potential_summand in self.potential_summands:
            summand_mask = mask &amp; ~df[potential_summand].isna()
            df.loc[summand_mask, self.target] = df[self.target] + df[potential_summand]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.Rule" href="#secfsdstools.f_standardize.bs_standardize.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp.apply"><code class="name flex">
<span>def <span class="ident">apply</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
    df.loc[mask, self.target] = 0.0  # initialize
    for potential_summand in self.potential_summands:
        summand_mask = mask &amp; ~df[potential_summand].isna()
        df.loc[summand_mask, self.target] = df[self.target] + df[potential_summand]</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp.get_input_tags"><code class="name flex">
<span>def <span class="ident">get_input_tags</span></span>(<span>self) ‑> Set[str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_input_tags(self) -&gt; Set[str]:
    result = {self.target}
    result.update(self.potential_summands)
    return result</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp.get_target_tag"><code class="name flex">
<span>def <span class="ident">get_target_tag</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_target_tag(self) -&gt; str:
    return self.target</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    # if the target was not set..
    return df[self.target].isna()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="secfsdstools.f_standardize" href="index.html">secfsdstools.f_standardize</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer">BalanceSheetStandardizer</a></code></h4>
<ul class="two-column">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_rename_rg" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_rename_rg">bs_rename_rg</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sum_completion" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sum_completion">bs_sum_completion</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sumup_rg" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sumup_rg">bs_sumup_rg</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.final_tags" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.final_tags">final_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.main_tags" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.main_tags">main_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.rule_tree" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.rule_tree">rule_tree</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld">BalanceSheetStandardizerOld</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.complete_special_rules" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.complete_special_rules">complete_special_rules</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.fill_still_isna_summands" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.fill_still_isna_summands">fill_still_isna_summands</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule">MissingSumRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule.apply" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule.get_input_tags" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule.get_target_tag" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule.get_target_tag">get_target_tag</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule.mask" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule.mask">mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule">MissingSummandRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.apply" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.get_input_tags" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.get_target_tag" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule.get_target_tag">get_target_tag</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.mask" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule.mask">mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.RenameRule" href="#secfsdstools.f_standardize.bs_standardize.RenameRule">RenameRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RenameRule.apply" href="#secfsdstools.f_standardize.bs_standardize.RenameRule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RenameRule.get_input_tags" href="#secfsdstools.f_standardize.bs_standardize.RenameRule.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RenameRule.get_target_tag" href="#secfsdstools.f_standardize.bs_standardize.RenameRule.get_target_tag">get_target_tag</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RenameRule.mask" href="#secfsdstools.f_standardize.bs_standardize.RenameRule.mask">mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.Rule" href="#secfsdstools.f_standardize.bs_standardize.Rule">Rule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.Rule.apply" href="#secfsdstools.f_standardize.bs_standardize.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.Rule.get_target_tag" href="#secfsdstools.f_standardize.bs_standardize.Rule.get_target_tag">get_target_tag</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.Rule.mask" href="#secfsdstools.f_standardize.bs_standardize.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.Rule.process" href="#secfsdstools.f_standardize.bs_standardize.Rule.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity">RuleEntity</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity.get_input_tags" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleEntity.process" href="#secfsdstools.f_standardize.bs_standardize.RuleEntity.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.RuleGroup" href="#secfsdstools.f_standardize.bs_standardize.RuleGroup">RuleGroup</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleGroup.get_input_tags" href="#secfsdstools.f_standardize.bs_standardize.RuleGroup.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleGroup.process" href="#secfsdstools.f_standardize.bs_standardize.RuleGroup.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor">RuleProcessor</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor.get_ruletree_descriptions" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor.get_ruletree_descriptions">get_ruletree_descriptions</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor.identifier_tags" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor.identifier_tags">identifier_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor.process" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator" href="#secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator">SumCompletionRuleGroupCreator</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator.create_group" href="#secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator.create_group">create_group</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp" href="#secfsdstools.f_standardize.bs_standardize.SumUp">SumUp</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp.apply" href="#secfsdstools.f_standardize.bs_standardize.SumUp.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp.get_input_tags" href="#secfsdstools.f_standardize.bs_standardize.SumUp.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp.get_target_tag" href="#secfsdstools.f_standardize.bs_standardize.SumUp.get_target_tag">get_target_tag</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp.mask" href="#secfsdstools.f_standardize.bs_standardize.SumUp.mask">mask</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>