<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>secfsdstools.f_standardize.bs_standardize API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>secfsdstools.f_standardize.bs_standardize</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from abc import ABC
from abc import abstractmethod
from typing import List, Optional, Set

import numpy as np
import pandas as pd
import pandera as pa

from secfsdstools.f_standardize.base_rules import CopyTagRule
from secfsdstools.f_standardize.rule_framework import Rule, RuleGroup, RuleEntity


class MissingSumRule(Rule):
    &#34;&#34;&#34; creates the sum in the sum_name column if all summand_names columnes have a value&#34;&#34;&#34;

    def __init__(self, sum_name: str, summand_names: List[str]):
        self.sum_name = sum_name
        self.summand_names = summand_names

    def get_target_tags(self) -&gt; List[str]:
        return [self.sum_name]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name}
        result.update(self.summand_names)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum_name has to be not set and all summand_names have to be set
        mask = df[self.sum_name].isna()
        for summand_name in self.summand_names:
            mask = mask &amp; ~df[summand_name].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.sum_name] = df[self.summand_names].sum(axis=1)

    def get_description(self) -&gt; str:
        return &#34;&#34;


class MissingSummandRule(Rule):

    def __init__(self, sum_name: str, missing_summand: str, existing_summands: List[str]):
        self.sum_name = sum_name
        self.missing_summand = missing_summand
        self.existing_summands = existing_summands

    def get_target_tags(self) -&gt; List[str]:
        return [self.missing_summand]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name, self.missing_summand}
        result.update(self.existing_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum and other_summands must be set, missing_summand must not be set
        mask = ~df[self.sum_name].isna()
        for summand_name in self.existing_summands:
            mask = mask &amp; ~df[summand_name].isna()
        mask = mask &amp; df[self.missing_summand].isna()
        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.missing_summand] = \
            df[self.sum_name] - df[self.existing_summands].sum(axis=1)

    def get_description(self) -&gt; str:
        return &#34;&#34;


class SumCompletionRuleGroupCreator:
    &#34;&#34;&#34;
    completes the missing value of a simple addition, if one is missing.
    E.G Assets = AssetsCurrent + AssetsNoneCurrent
    &#34;&#34;&#34;

    @staticmethod
    def create_group(sum_tag: str, summand_tags: List[str], prefix: str) -&gt; RuleGroup:
        rules: List[RuleEntity] = [MissingSumRule(sum_name=sum_tag,
                                                  summand_names=summand_tags)]
        for summand in summand_tags:
            others = summand_tags.copy()
            others.remove(summand)
            rules.append(MissingSummandRule(sum_name=sum_tag, missing_summand=summand,
                                            existing_summands=others))
        return RuleGroup(rules=rules, prefix=prefix)


class SumUp(Rule):
    &#34;&#34;&#34;Sums app the available Summands to a new target column&#34;&#34;&#34;

    def __init__(self, target: str, potential_summands: List[str]):
        self.target = target
        self.potential_summands = potential_summands

    def get_target_tags(self) -&gt; List[str]:
        return [self.target]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.target}
        result.update(self.potential_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the target was not set..
        return df[self.target].isna()

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.target] = 0.0  # initialize
        for potential_summand in self.potential_summands:
            summand_mask = mask &amp; ~df[potential_summand].isna()
            df.loc[summand_mask, self.target] = df[self.target] + df[potential_summand]

    def get_description(self) -&gt; str:
        return &#34;&#34;


class SetSumIfOneOnlySummand(Rule):
    &#34;&#34;&#34;
    If the sumt_tag is nan and only one summand has a value, then the
    target gets the copy of the Value and the other summands are set to zero.
    &#34;&#34;&#34;

    def __init__(self, sum_tag: str, summand_set: str, summands_nan: List[str]):
        self.sum_tag = sum_tag
        self.summand_set = summand_set
        self.summands_nan = summands_nan

    def get_target_tags(self) -&gt; List[str]:
        return [self.sum_tag, *self.summands_nan]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_tag, self.summand_set}
        result.update(self.summands_nan)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the target was not set..

        mask = df[self.sum_tag].isna() &amp; ~df[self.summand_set].isna()
        for summand_nan in self.summands_nan:
            mask = mask &amp; df[summand_nan].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.sum_tag] = df[self.summand_set]  # initialize
        for summand_nan in self.summands_nan:
            df.loc[mask, summand_nan] = 0.0

    def get_description(self) -&gt; str:
        return &#34;&#34;


class CleanUpCopyToFirstSummand(Rule):
    &#34;&#34;&#34; if the sum_tag is set and the first summand and the other summands are nan,
    then copy the target value to the first summand and set the other summands to &#39;0.0&#39; &#34;&#34;&#34;

    def __init__(self, sum_tag: str, first_summand: str, other_summands: List[str]):
        self.sum_tag = sum_tag
        self.first_summand = first_summand
        self.other_summands = other_summands

    def get_target_tags(self) -&gt; List[str]:
        return [self.first_summand, *self.other_summands]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_tag, self.first_summand}
        result.update(self.other_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the sum_tag was not set..

        mask = ~df[self.sum_tag].isna() &amp; df[self.first_summand].isna()
        for other_summand in self.other_summands:
            mask = mask &amp; df[other_summand].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.first_summand] = df[self.sum_tag]  # initialize
        for other_summand in self.other_summands:
            df.loc[mask, other_summand] = 0.0

    def get_description(self) -&gt; str:
        return &#34;&#34;


class CleanUpSumUpCorrections(Rule):
    &#34;&#34;&#34; it happens, that the values for Assets and AssetsNoncurrent
    where mixed  up. example: 0001692981-19-000022
    So instead of Assets = AssetsCurrent + AssetsNoncurrent
    it matches AssetsNoncurrent = Assets + AssetsCurrent.

    so the first parameter is the sum_tag, e.g. Assets
    the mixed_up_summand is the name of the summand that was mixed with the sum_tag
    the other_summand is the summand with the correct value, e.g. AssetsCurrent
    &#34;&#34;&#34;

    def __init__(self, sum_tag: str, mixed_up_summand: str, other_summand: str):
        self.sum_tag = sum_tag
        self.mixed_up_summand = mixed_up_summand
        self.other_summand = other_summand

    def get_target_tags(self) -&gt; List[str]:
        return [self.sum_tag, self.mixed_up_summand]

    def get_input_tags(self) -&gt; Set[str]:
        return {self.sum_tag, self.mixed_up_summand, self.other_summand}

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        return (df[self.mixed_up_summand] == df[self.sum_tag] + df[self.other_summand]) \
               &amp; (df[self.other_summand] &gt; 0)

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        mixed_up_values = df[self.mixed_up_summand].copy()
        df.loc[mask, self.mixed_up_summand] = df[self.sum_tag]
        df.loc[mask, self.sum_tag] = mixed_up_values

    def get_description(self) -&gt; str:
        return &#34;&#34;


class ValidationRule(ABC):

    def __init__(self, id: str):
        self.id = id

    @abstractmethod
    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        pass

    @abstractmethod
    def calculate_error(self, df: pd.DataFrame, mask: pa.typing.Series[bool]) -&gt; \
            pa.typing.Series[np.float64]:
        pass

    def validate(self, df: pd.DataFrame):
        mask = self.mask(df)
        error = self.calculate_error(df, mask)

        error_column_name = f&#39;{self.id}_error&#39;
        cat_column_name = f&#39;{self.id}_cat&#39;

        df[error_column_name] = None
        df.loc[mask, error_column_name] = error

        df.loc[mask, cat_column_name] = 100  # gt &gt; 0.1 / 10%
        df.loc[df[error_column_name] &lt;= 0.1, cat_column_name] = 10  # 5-10 %
        df.loc[df[error_column_name] &lt;= 0.05, cat_column_name] = 5  # 1-5 %
        df.loc[df[error_column_name] &lt;= 0.01, cat_column_name] = 1  # &lt; 1%
        df.loc[df[error_column_name] == 0.0, cat_column_name] = 0  # exact match


class SumValidationRule(ValidationRule):

    def __init__(self, id: str, sum_tag: str, summands: List[str]):
        super().__init__(id)
        self.sum_tag = sum_tag
        self.summands = summands

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        mask = ~df[self.sum_tag].isna()
        for summand in self.summands:
            mask = mask &amp; ~df[summand].isna()

        return mask

    def calculate_error(self, df: pd.DataFrame, mask: pa.typing.Series[bool]) -&gt; \
            pa.typing.Series[np.float64]:
        return ((df[self.sum_tag] - df[self.summands].sum(axis=&#39;columns&#39;)) / df[self.sum_tag]).abs()


class RuleProcessor:
    identifier_tags = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]

    def __init__(self, rule_tree: RuleGroup, clean_up_rule_tree: RuleGroup,
                 validation_rules: List[ValidationRule],
                 iterations: int, main_tags: List[str], final_tags: List[str],
                 filter_for_main_report: bool = True, invert_negated: bool = True):
        self.rule_tree = rule_tree
        self.clean_up_rule_tree = clean_up_rule_tree
        self.validation_rules = validation_rules
        self.iterations = iterations
        self.main_tags = main_tags
        self.final_tags = final_tags
        self.filter_for_main_report = filter_for_main_report
        self.invert_negated = invert_negated

        self.final_col_order = self.identifier_tags + self.final_tags

        self.preprocess_dupliate_log_df: Optional[pd.DataFrame] = None
        self.log_df: Optional[pd.DataFrame] = None
        self.applied_rules_sum_df: Optional[pd.DataFrame] = None
        self.stats: Optional[pd.DataFrame] = None

    def get_ruletree_descriptions(self):
        # todo
        pass

    def process(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        all_input_tags = self.rule_tree.get_input_tags()

        relevant_df = \
            df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;uom&#39;, &#39;value&#39;, &#39;report&#39;, &#39;line&#39;,
                &#39;negating&#39;]][df.tag.isin(all_input_tags)]

        # preprocessing ..
        #  - deduplicate
        cpy_df = self._deduplicate(relevant_df).copy()

        #  - invert_negated
        if self.invert_negated:
            cpy_df.loc[cpy_df.negating == 1, &#39;value&#39;] = -cpy_df.value

        # pivot the table, so that the tags become columns
        # todo: folgende Zeile sollte nicht mehr notwendig sein, sobald alle Regeln implementiert sind
        expected_tags = all_input_tags.union(self.final_tags)
        pivot_df = self._pivot(df=cpy_df, expected_tags=expected_tags)

        if self.filter_for_main_report:
            pivot_df = self._filter_pivot_for_main_reports(pivot_df)

        pivot_df_index_cols = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;, &#39;uom&#39;]
        self.log_df = pivot_df[pivot_df_index_cols].copy()

        total_length = len(pivot_df)

        # calculate_pre_stats:
        pre_apply_df = pivot_df[self.final_col_order]
        self.pre_stats = self._calculate_stats(pivot_df=pre_apply_df)
        self.pre_stats.name = &#34;pre&#34;

        self.stats = pd.DataFrame(self.pre_stats)
        self.stats[&#39;pre_rel&#39;] = self.stats.pre / total_length

        self.stats = pd.DataFrame(self.pre_stats)

        for i in range(self.iterations):
            # set ids of the rules in the tree, use the iteration number as prefix
            self.rule_tree.set_id(parent_prefix=f&#34;{i}_&#34;)

            # apply the rule_tree
            self.rule_tree.process(df=pivot_df, log_df=self.log_df)

            self.post_stats = self._calculate_stats(pivot_df=pivot_df)
            self.post_stats.name = f&#34;post_{i}&#34;

            self.stats = self.stats.join(self.post_stats)
            self.stats[self.post_stats.name + &#39;_rel&#39;] = \
                self.stats[self.post_stats.name] / total_length
            self.stats[self.post_stats.name + &#39;_red&#39;] = \
                1 - (self.stats[self.post_stats.name] / self.stats.pre)

        # clean up rules
        self.clean_up_rule_tree.process(df=pivot_df, log_df=self.log_df)

        # calculate cleanup stats
        self.post_cleanup = self._calculate_stats(pivot_df=pivot_df)
        self.post_cleanup.name = &#34;cleanup&#34;
        self.stats = self.stats.join(self.post_cleanup)
        self.stats[self.post_cleanup.name + &#39;_rel&#39;] = \
            self.stats[self.post_cleanup.name] / total_length
        self.stats[self.post_cleanup.name + &#39;_red&#39;] = \
            1 - (self.stats[self.post_cleanup.name] / self.stats.pre)

        # create a meaningful order
        pivot_df = pivot_df[self.final_col_order].copy()

        # apply validation rules
        for validation_rule in self.validation_rules:
            validation_rule.validate(pivot_df)

        # caculate log_df summaries
        if self.log_df is not None:
            # filter for rule columns but making sure the order stays the same
            rule_columns = [x for x in self.log_df.columns if x not in pivot_df_index_cols]
            self.applied_rules_sum_df = self.log_df[rule_columns].sum()

        return pivot_df

    def _deduplicate(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        # find duplicated entries
        # sometimes, only single tags are duplicated, however, there are also reports
        # where all tags of a report are duplicated, maybe due to a problem with processing
        duplicates_s = \
            df.duplicated([&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;uom&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;value&#39;])

        self.preprocess_dupliate_log_df = df[duplicates_s] \
            [[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;uom&#39;, &#39;version&#39;, &#39;ddate&#39;]].copy()

        return df[~duplicates_s]

    def _filter_pivot_for_main_reports(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Some reports have more than one &#39;report number&#39; (column report) for a
            certain statement. Generally, the one with the most tags is the one to take.
            This method operates on the pivoted data and counts the none-values of the
            &#34;main columns&#34;. The main columns are the fields, that generally should be there.
             &#34;&#34;&#34;

        cpy_pivot_df = pivot_df.copy()

        cpy_pivot_df[&#39;nan_count&#39;] = cpy_pivot_df[self.main_tags].isna().sum(axis=1)
        cpy_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;nan_count&#39;], inplace=True)
        cpy_pivot_df = cpy_pivot_df.groupby([&#39;adsh&#39;, &#39;coreg&#39;]).last()
        cpy_pivot_df.reset_index(inplace=True)
        return cpy_pivot_df

    def _calculate_stats(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        return pivot_df[self.final_tags].isna().sum(axis=0)

    def _pivot(self, df: pd.DataFrame, expected_tags: Set[str]) -&gt; pd.DataFrame:
        # it is possible, that the same number appears multiple times in different lines,
        # therefore, duplicates have to be removed, otherwise pivot is not possible
        relevant_df = df[
            [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;value&#39;, &#39;uom&#39;, &#39;ddate&#39;]].drop_duplicates()

        pivot_df = relevant_df.pivot(index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;uom&#39;, &#39;ddate&#39;],
                                     columns=&#39;tag&#39;,
                                     values=&#39;value&#39;)
        pivot_df.reset_index(inplace=True)
        missing_cols = set(expected_tags) - set(pivot_df.columns)
        for missing_col in missing_cols:
            pivot_df[missing_col] = np.nan
        pivot_df[&#39;nan_count&#39;] = np.nan
        return pivot_df


class BalanceSheetStandardizer(RuleProcessor):
    &#34;&#34;&#34;
    The goal of this Standardizer is to create BalanceSheets that are compareable,
    meaning that they have the same tags.

    At the end, the standardized BS contains the following columns
    Assets
       AssetsCurrent
           Cash
       AssetsNoncurrent
    Liabilities
       LiabilitiesCurrent
       LiabilitiesNoncurrent
    OwnerEquity
        PaidInCapital
        RetainedEarnings
    LiabilitiesAndOwnerEquity

    &#34;&#34;&#34;

    bs_rename_rg = RuleGroup(
        rules=[
            # sometimes, the total Assets is contained in the AssetsNet tag
            CopyTagRule(original=&#39;AssetsNet&#39;, target=&#39;Assets&#39;),
            # either there is a StockholderEquity tag or a PartnersCapital tag,
            # but both to never appear together
            CopyTagRule(original=&#39;PartnersCapital&#39;, target=&#39;OwnerEquity&#39;),
            CopyTagRule(original=&#39;StockholdersEquity&#39;, target=&#39;OwnerEquity&#39;),
            CopyTagRule(original=&#39;CashAndCashEquivalentsAtCarryingValue&#39;, target=&#39;Cash&#39;),
            CopyTagRule(original=&#39;LiabilitiesAndStockholdersEquity&#39;,
                        target=&#39;LiabilitiesAndOwnerEquity&#39;)

            # RenameRule(
            #     original=&#39;StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest&#39;,
            #     target=&#39;Equity&#39;),
            # RenameRule(original=&#39;RetainedEarningsAppropriated&#39;, target=&#39;RetainedEarnings&#39;),
            # RenameRule(original=&#39;RetainedEarningsAccumulatedDeficit&#39;, target=&#39;RetainedEarnings&#39;)
        ],
        prefix=&#34;BR&#34;
    )

    # todo: CashOther wird noch nirgends verwendet
    bs_sumup_rg = RuleGroup(
        rules=[SumUp(
            target=&#39;CashOther&#39;,
            potential_summands=[
                &#39;CashAndCashEquivalentsAtFairValue&#39;,
                &#39;CashAndDueFromBanks&#39;,
                &#39;CashCashEquivalentsAndFederalFundsSold&#39;,
                &#39;RestrictedCashAndCashEquivalentsAtCarryingValue&#39;,
                &#39;CashAndCashEquivalentsInForeignCurrencyAtCarryingValue&#39;])],
        prefix=&#34;SU&#34;
    )

    bs_sum_completion = RuleGroup(
        prefix=&#34;SC&#34;,
        rules=[
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Assets&#39;,
                summand_tags=[&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;],
                prefix=&#34;Ass&#34;
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Assets&#39;,
                summand_set=&#39;AssetsCurrent&#39;,
                summands_nan=[&#39;AssetsNoncurrent&#39;]
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Assets&#39;,
                summand_set=&#39;AssetsNoncurrent&#39;,
                summands_nan=[&#39;AssetsCurrent&#39;]
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Liabilities&#39;,
                summand_tags=[&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;],
                prefix=&#34;Lia&#34;
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Liabilities&#39;,
                summand_set=&#39;LiabilitiesCurrent&#39;,
                summands_nan=[&#39;LiabilitiesNoncurrent&#39;]
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Liabilities&#39;,
                summand_set=&#39;LiabilitiesNoncurrent&#39;,
                summands_nan=[&#39;LiabilitiesCurrent&#39;]
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;AssLiaOwe&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;OwnerEquity&#39;],
                prefix=&#34;Ass2&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;LiabilitiesAndOwnerEquity&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;OwnerEquity&#39;],
                prefix=&#34;LiaOwnEq&#34;
            )
        ])

    rule_tree = RuleGroup(prefix=&#34;BS_&#34;,
                          rules=[
                              bs_rename_rg,
                              bs_sumup_rg,
                              bs_sum_completion,
                          ])

    cleanup_rule_tree = RuleGroup(prefix=&#34;BS_CL_&#34;,
                                  rules=[
                                      CleanUpCopyToFirstSummand(sum_tag=&#39;Assets&#39;,
                                                                first_summand=&#39;AssetsCurrent&#39;,
                                                                other_summands=[
                                                                    &#39;AssetsNoncurrent&#39;]),
                                      CleanUpCopyToFirstSummand(sum_tag=&#39;Liabilities&#39;,
                                                                first_summand=&#39;LiabilitiesCurrent&#39;,
                                                                other_summands=[
                                                                    &#39;LiabilitiesNoncurrent&#39;]),
                                      CleanUpSumUpCorrections(sum_tag=&#39;Assets&#39;,
                                                              mixed_up_summand=&#39;AssetsNoncurrent&#39;,
                                                              other_summand=&#39;AssetsCurrent&#39;),
                                      CleanUpSumUpCorrections(sum_tag=&#39;Assets&#39;,
                                                              mixed_up_summand=&#39;AssetsCurrent&#39;,
                                                              other_summand=&#39;AssetsNoncurrent&#39;),
                                  ])

    validation_rules: List[ValidationRule] = [
        SumValidationRule(id=&#39;AssetsCheck&#39;,
                          sum_tag=&#39;Assets&#39;,
                          summands=[&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;]),
        SumValidationRule(id=&#39;LiabilitiesCheck&#39;,
                          sum_tag=&#39;Liabilities&#39;,
                          summands=[&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;])
    ]

    # these are the columns that finally are returned after the standardization
    final_tags: List[str] = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                             &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;,
                             &#39;OwnerEquity&#39;, &#39;LiabilitiesAndOwnerEquity&#39;,
                             &#39;InventoryNet&#39;,
                             &#39;Cash&#39;,
                             &#39;CashOther&#39;,
                             &#39;RetainedEarnings&#39;
                             ]

    # used to evaluate if a report is the main balancesheet report
    # inside a report, there can be several different tables (different report nr)
    # which stmt value is BS.
    # however, we might be only interested in the &#34;major&#34; BS report. Usually this is the
    # one which has the least nan in the following columns
    main_tags = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                 &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;]

    def __init__(self, filter_for_main_report: bool = False, iterations: int = 3):
        super().__init__(rule_tree=self.rule_tree,
                         clean_up_rule_tree=self.cleanup_rule_tree,
                         validation_rules=self.validation_rules,
                         iterations=iterations,
                         main_tags=self.main_tags, final_tags=self.final_tags,
                         filter_for_main_report=filter_for_main_report)


# there are pre-pivot and post-pivot rules ..
# in order to make a pre assesement on how many fields could be filled, we would need to have
# pivot run without applying any rules, just pivot and return the desired colums,
# or just the basic renaming ...
# but without going for changing default names

# man könnte noch checks einbauen, ob z.B. die Summen definition gültig sind,
# d.h., dass der Wert der Summe in etwa der Summe der Werte der Summanden entsprciht


class BalanceSheetStandardizerOld:

    def fill_still_isna_summands(self, df: pd.DataFrame):
        &#34;&#34;&#34; if we are left with unset summands&#34;&#34;&#34;

        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        for total, summands in BalanceSheetStandardizerOld.sum_definition.items():
            summand_1 = summands[0]
            summand_2 = summands[1]

            # if only the total is present, we assume that only the first summand (eg. currentassets are present)
            # that is not really proper.
            mask_total_nosum1_nosum2 = (~df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_total_nosum1_nosum2, summand_1] = df[total]
            df.loc[mask_total_nosum1_nosum2, summand_2] = 0.0

            # if only the first summand is present, wie assume that the total is equal to the first summand
            # and that the second summand is 0
            mask_nototal_sum1_nosum2 = (df[total].isna() &amp;
                                        ~df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_nototal_sum1_nosum2, total] = df[summand_1]
            df.loc[mask_nototal_sum1_nosum2, summand_2] = 0.0

            # if only the second summand is present, wie assume that the total is equal to the second summand
            # and that the first  summand is 0
            mask_nototal_nosum1_sum2 = (df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        ~df[summand_2].isna())
            df.loc[mask_nototal_nosum1_sum2, total] = df[summand_2]
            df.loc[mask_nototal_nosum1_sum2, summand_1] = 0.0

    def complete_special_rules(self, df: pd.DataFrame):
        &#34;&#34;&#34;
        Special rules which help to complete the information
        &#34;&#34;&#34;

        # self._basic_sum_completion(df, total=&#39;Assets&#39;, summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)
        #
        # # actually, LiabilitiesAndStockholdersEquity should have the same value as Assets
        # self._basic_sum_completion(df, total=&#39;LiabilitiesAndStockholdersEquity&#39;,
        #                            summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)

        # run complete sum again, since total fields could be present now
        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        self.complete_sums(df)

        self.fill_still_isna_summands(df)

        # if Equity == -Liabilities and Assets is nan, then
        # Assets, AssetsCurrent, and AssetsNoncurrent is 0.0
        mask = (df.Equity == -df.Liabilities) &amp; df.Assets.isna()
        df.loc[mask, &#39;Assets&#39;] = 0.0
        df.loc[mask, &#39;AssetsCurrent&#39;] = 0.0
        df.loc[mask, &#39;AssetsNoncurrent&#39;] = 0.0

        # if Cash is not set, then use CashOther to set Cash
        mask = df.Cash.isna()
        df.loc[mask, &#39;Cash&#39;] = df.CashOther

        # set to zero
        mask = df.InventoryNet.isna()
        df.loc[mask, &#39;InventoryNet&#39;] = 0.0</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer"><code class="flex name class">
<span>class <span class="ident">BalanceSheetStandardizer</span></span>
<span>(</span><span>filter_for_main_report: bool = False, iterations: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>The goal of this Standardizer is to create BalanceSheets that are compareable,
meaning that they have the same tags.</p>
<p>At the end, the standardized BS contains the following columns
Assets
AssetsCurrent
Cash
AssetsNoncurrent
Liabilities
LiabilitiesCurrent
LiabilitiesNoncurrent
OwnerEquity
PaidInCapital
RetainedEarnings
LiabilitiesAndOwnerEquity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceSheetStandardizer(RuleProcessor):
    &#34;&#34;&#34;
    The goal of this Standardizer is to create BalanceSheets that are compareable,
    meaning that they have the same tags.

    At the end, the standardized BS contains the following columns
    Assets
       AssetsCurrent
           Cash
       AssetsNoncurrent
    Liabilities
       LiabilitiesCurrent
       LiabilitiesNoncurrent
    OwnerEquity
        PaidInCapital
        RetainedEarnings
    LiabilitiesAndOwnerEquity

    &#34;&#34;&#34;

    bs_rename_rg = RuleGroup(
        rules=[
            # sometimes, the total Assets is contained in the AssetsNet tag
            CopyTagRule(original=&#39;AssetsNet&#39;, target=&#39;Assets&#39;),
            # either there is a StockholderEquity tag or a PartnersCapital tag,
            # but both to never appear together
            CopyTagRule(original=&#39;PartnersCapital&#39;, target=&#39;OwnerEquity&#39;),
            CopyTagRule(original=&#39;StockholdersEquity&#39;, target=&#39;OwnerEquity&#39;),
            CopyTagRule(original=&#39;CashAndCashEquivalentsAtCarryingValue&#39;, target=&#39;Cash&#39;),
            CopyTagRule(original=&#39;LiabilitiesAndStockholdersEquity&#39;,
                        target=&#39;LiabilitiesAndOwnerEquity&#39;)

            # RenameRule(
            #     original=&#39;StockholdersEquityIncludingPortionAttributableToNoncontrollingInterest&#39;,
            #     target=&#39;Equity&#39;),
            # RenameRule(original=&#39;RetainedEarningsAppropriated&#39;, target=&#39;RetainedEarnings&#39;),
            # RenameRule(original=&#39;RetainedEarningsAccumulatedDeficit&#39;, target=&#39;RetainedEarnings&#39;)
        ],
        prefix=&#34;BR&#34;
    )

    # todo: CashOther wird noch nirgends verwendet
    bs_sumup_rg = RuleGroup(
        rules=[SumUp(
            target=&#39;CashOther&#39;,
            potential_summands=[
                &#39;CashAndCashEquivalentsAtFairValue&#39;,
                &#39;CashAndDueFromBanks&#39;,
                &#39;CashCashEquivalentsAndFederalFundsSold&#39;,
                &#39;RestrictedCashAndCashEquivalentsAtCarryingValue&#39;,
                &#39;CashAndCashEquivalentsInForeignCurrencyAtCarryingValue&#39;])],
        prefix=&#34;SU&#34;
    )

    bs_sum_completion = RuleGroup(
        prefix=&#34;SC&#34;,
        rules=[
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Assets&#39;,
                summand_tags=[&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;],
                prefix=&#34;Ass&#34;
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Assets&#39;,
                summand_set=&#39;AssetsCurrent&#39;,
                summands_nan=[&#39;AssetsNoncurrent&#39;]
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Assets&#39;,
                summand_set=&#39;AssetsNoncurrent&#39;,
                summands_nan=[&#39;AssetsCurrent&#39;]
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;Liabilities&#39;,
                summand_tags=[&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;],
                prefix=&#34;Lia&#34;
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Liabilities&#39;,
                summand_set=&#39;LiabilitiesCurrent&#39;,
                summands_nan=[&#39;LiabilitiesNoncurrent&#39;]
            ),
            SetSumIfOneOnlySummand(
                sum_tag=&#39;Liabilities&#39;,
                summand_set=&#39;LiabilitiesNoncurrent&#39;,
                summands_nan=[&#39;LiabilitiesCurrent&#39;]
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;AssLiaOwe&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;OwnerEquity&#39;],
                prefix=&#34;Ass2&#34;
            ),
            SumCompletionRuleGroupCreator.create_group(
                sum_tag=&#39;LiabilitiesAndOwnerEquity&#39;,
                summand_tags=[&#39;Liabilities&#39;, &#39;OwnerEquity&#39;],
                prefix=&#34;LiaOwnEq&#34;
            )
        ])

    rule_tree = RuleGroup(prefix=&#34;BS_&#34;,
                          rules=[
                              bs_rename_rg,
                              bs_sumup_rg,
                              bs_sum_completion,
                          ])

    cleanup_rule_tree = RuleGroup(prefix=&#34;BS_CL_&#34;,
                                  rules=[
                                      CleanUpCopyToFirstSummand(sum_tag=&#39;Assets&#39;,
                                                                first_summand=&#39;AssetsCurrent&#39;,
                                                                other_summands=[
                                                                    &#39;AssetsNoncurrent&#39;]),
                                      CleanUpCopyToFirstSummand(sum_tag=&#39;Liabilities&#39;,
                                                                first_summand=&#39;LiabilitiesCurrent&#39;,
                                                                other_summands=[
                                                                    &#39;LiabilitiesNoncurrent&#39;]),
                                      CleanUpSumUpCorrections(sum_tag=&#39;Assets&#39;,
                                                              mixed_up_summand=&#39;AssetsNoncurrent&#39;,
                                                              other_summand=&#39;AssetsCurrent&#39;),
                                      CleanUpSumUpCorrections(sum_tag=&#39;Assets&#39;,
                                                              mixed_up_summand=&#39;AssetsCurrent&#39;,
                                                              other_summand=&#39;AssetsNoncurrent&#39;),
                                  ])

    validation_rules: List[ValidationRule] = [
        SumValidationRule(id=&#39;AssetsCheck&#39;,
                          sum_tag=&#39;Assets&#39;,
                          summands=[&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;]),
        SumValidationRule(id=&#39;LiabilitiesCheck&#39;,
                          sum_tag=&#39;Liabilities&#39;,
                          summands=[&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;])
    ]

    # these are the columns that finally are returned after the standardization
    final_tags: List[str] = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                             &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;,
                             &#39;OwnerEquity&#39;, &#39;LiabilitiesAndOwnerEquity&#39;,
                             &#39;InventoryNet&#39;,
                             &#39;Cash&#39;,
                             &#39;CashOther&#39;,
                             &#39;RetainedEarnings&#39;
                             ]

    # used to evaluate if a report is the main balancesheet report
    # inside a report, there can be several different tables (different report nr)
    # which stmt value is BS.
    # however, we might be only interested in the &#34;major&#34; BS report. Usually this is the
    # one which has the least nan in the following columns
    main_tags = [&#39;Assets&#39;, &#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;,
                 &#39;Liabilities&#39;, &#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;]

    def __init__(self, filter_for_main_report: bool = False, iterations: int = 3):
        super().__init__(rule_tree=self.rule_tree,
                         clean_up_rule_tree=self.cleanup_rule_tree,
                         validation_rules=self.validation_rules,
                         iterations=iterations,
                         main_tags=self.main_tags, final_tags=self.final_tags,
                         filter_for_main_report=filter_for_main_report)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor">RuleProcessor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_rename_rg"><code class="name">var <span class="ident">bs_rename_rg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sum_completion"><code class="name">var <span class="ident">bs_sum_completion</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sumup_rg"><code class="name">var <span class="ident">bs_sumup_rg</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.cleanup_rule_tree"><code class="name">var <span class="ident">cleanup_rule_tree</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.final_tags"><code class="name">var <span class="ident">final_tags</span> : List[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.main_tags"><code class="name">var <span class="ident">main_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.rule_tree"><code class="name">var <span class="ident">rule_tree</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.validation_rules"><code class="name">var <span class="ident">validation_rules</span> : List[<a title="secfsdstools.f_standardize.bs_standardize.ValidationRule" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule">ValidationRule</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld"><code class="flex name class">
<span>class <span class="ident">BalanceSheetStandardizerOld</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BalanceSheetStandardizerOld:

    def fill_still_isna_summands(self, df: pd.DataFrame):
        &#34;&#34;&#34; if we are left with unset summands&#34;&#34;&#34;

        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        for total, summands in BalanceSheetStandardizerOld.sum_definition.items():
            summand_1 = summands[0]
            summand_2 = summands[1]

            # if only the total is present, we assume that only the first summand (eg. currentassets are present)
            # that is not really proper.
            mask_total_nosum1_nosum2 = (~df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_total_nosum1_nosum2, summand_1] = df[total]
            df.loc[mask_total_nosum1_nosum2, summand_2] = 0.0

            # if only the first summand is present, wie assume that the total is equal to the first summand
            # and that the second summand is 0
            mask_nototal_sum1_nosum2 = (df[total].isna() &amp;
                                        ~df[summand_1].isna() &amp;
                                        df[summand_2].isna())
            df.loc[mask_nototal_sum1_nosum2, total] = df[summand_1]
            df.loc[mask_nototal_sum1_nosum2, summand_2] = 0.0

            # if only the second summand is present, wie assume that the total is equal to the second summand
            # and that the first  summand is 0
            mask_nototal_nosum1_sum2 = (df[total].isna() &amp;
                                        df[summand_1].isna() &amp;
                                        ~df[summand_2].isna())
            df.loc[mask_nototal_nosum1_sum2, total] = df[summand_2]
            df.loc[mask_nototal_nosum1_sum2, summand_1] = 0.0

    def complete_special_rules(self, df: pd.DataFrame):
        &#34;&#34;&#34;
        Special rules which help to complete the information
        &#34;&#34;&#34;

        # self._basic_sum_completion(df, total=&#39;Assets&#39;, summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)
        #
        # # actually, LiabilitiesAndStockholdersEquity should have the same value as Assets
        # self._basic_sum_completion(df, total=&#39;LiabilitiesAndStockholdersEquity&#39;,
        #                            summand_1=&#39;Liabilities&#39;,
        #                            summand_2=&#39;Equity&#39;)

        # run complete sum again, since total fields could be present now
        # for:
        # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
        # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
        self.complete_sums(df)

        self.fill_still_isna_summands(df)

        # if Equity == -Liabilities and Assets is nan, then
        # Assets, AssetsCurrent, and AssetsNoncurrent is 0.0
        mask = (df.Equity == -df.Liabilities) &amp; df.Assets.isna()
        df.loc[mask, &#39;Assets&#39;] = 0.0
        df.loc[mask, &#39;AssetsCurrent&#39;] = 0.0
        df.loc[mask, &#39;AssetsNoncurrent&#39;] = 0.0

        # if Cash is not set, then use CashOther to set Cash
        mask = df.Cash.isna()
        df.loc[mask, &#39;Cash&#39;] = df.CashOther

        # set to zero
        mask = df.InventoryNet.isna()
        df.loc[mask, &#39;InventoryNet&#39;] = 0.0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.complete_special_rules"><code class="name flex">
<span>def <span class="ident">complete_special_rules</span></span>(<span>self, df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>Special rules which help to complete the information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete_special_rules(self, df: pd.DataFrame):
    &#34;&#34;&#34;
    Special rules which help to complete the information
    &#34;&#34;&#34;

    # self._basic_sum_completion(df, total=&#39;Assets&#39;, summand_1=&#39;Liabilities&#39;,
    #                            summand_2=&#39;Equity&#39;)
    #
    # # actually, LiabilitiesAndStockholdersEquity should have the same value as Assets
    # self._basic_sum_completion(df, total=&#39;LiabilitiesAndStockholdersEquity&#39;,
    #                            summand_1=&#39;Liabilities&#39;,
    #                            summand_2=&#39;Equity&#39;)

    # run complete sum again, since total fields could be present now
    # for:
    # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
    # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
    self.complete_sums(df)

    self.fill_still_isna_summands(df)

    # if Equity == -Liabilities and Assets is nan, then
    # Assets, AssetsCurrent, and AssetsNoncurrent is 0.0
    mask = (df.Equity == -df.Liabilities) &amp; df.Assets.isna()
    df.loc[mask, &#39;Assets&#39;] = 0.0
    df.loc[mask, &#39;AssetsCurrent&#39;] = 0.0
    df.loc[mask, &#39;AssetsNoncurrent&#39;] = 0.0

    # if Cash is not set, then use CashOther to set Cash
    mask = df.Cash.isna()
    df.loc[mask, &#39;Cash&#39;] = df.CashOther

    # set to zero
    mask = df.InventoryNet.isna()
    df.loc[mask, &#39;InventoryNet&#39;] = 0.0</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.fill_still_isna_summands"><code class="name flex">
<span>def <span class="ident">fill_still_isna_summands</span></span>(<span>self, df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"><p>if we are left with unset summands</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fill_still_isna_summands(self, df: pd.DataFrame):
    &#34;&#34;&#34; if we are left with unset summands&#34;&#34;&#34;

    # for:
    # &#39;Assets&#39;: (&#39;AssetsCurrent&#39;, &#39;AssetsNoncurrent&#39;),
    # &#39;Liabilities&#39;: (&#39;LiabilitiesCurrent&#39;, &#39;LiabilitiesNoncurrent&#39;)
    for total, summands in BalanceSheetStandardizerOld.sum_definition.items():
        summand_1 = summands[0]
        summand_2 = summands[1]

        # if only the total is present, we assume that only the first summand (eg. currentassets are present)
        # that is not really proper.
        mask_total_nosum1_nosum2 = (~df[total].isna() &amp;
                                    df[summand_1].isna() &amp;
                                    df[summand_2].isna())
        df.loc[mask_total_nosum1_nosum2, summand_1] = df[total]
        df.loc[mask_total_nosum1_nosum2, summand_2] = 0.0

        # if only the first summand is present, wie assume that the total is equal to the first summand
        # and that the second summand is 0
        mask_nototal_sum1_nosum2 = (df[total].isna() &amp;
                                    ~df[summand_1].isna() &amp;
                                    df[summand_2].isna())
        df.loc[mask_nototal_sum1_nosum2, total] = df[summand_1]
        df.loc[mask_nototal_sum1_nosum2, summand_2] = 0.0

        # if only the second summand is present, wie assume that the total is equal to the second summand
        # and that the first  summand is 0
        mask_nototal_nosum1_sum2 = (df[total].isna() &amp;
                                    df[summand_1].isna() &amp;
                                    ~df[summand_2].isna())
        df.loc[mask_nototal_nosum1_sum2, total] = df[summand_2]
        df.loc[mask_nototal_nosum1_sum2, summand_1] = 0.0</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.CleanUpCopyToFirstSummand"><code class="flex name class">
<span>class <span class="ident">CleanUpCopyToFirstSummand</span></span>
<span>(</span><span>sum_tag: str, first_summand: str, other_summands: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>if the sum_tag is set and the first summand and the other summands are nan,
then copy the target value to the first summand and set the other summands to '0.0'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CleanUpCopyToFirstSummand(Rule):
    &#34;&#34;&#34; if the sum_tag is set and the first summand and the other summands are nan,
    then copy the target value to the first summand and set the other summands to &#39;0.0&#39; &#34;&#34;&#34;

    def __init__(self, sum_tag: str, first_summand: str, other_summands: List[str]):
        self.sum_tag = sum_tag
        self.first_summand = first_summand
        self.other_summands = other_summands

    def get_target_tags(self) -&gt; List[str]:
        return [self.first_summand, *self.other_summands]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_tag, self.first_summand}
        result.update(self.other_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the sum_tag was not set..

        mask = ~df[self.sum_tag].isna() &amp; df[self.first_summand].isna()
        for other_summand in self.other_summands:
            mask = mask &amp; df[other_summand].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.first_summand] = df[self.sum_tag]  # initialize
        for other_summand in self.other_summands:
            df.loc[mask, other_summand] = 0.0

    def get_description(self) -&gt; str:
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.rule_framework.RuleEntity" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.CleanUpCopyToFirstSummand.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.apply" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_description" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_description">get_description</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_input_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags">get_target_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str">get_target_tags_str</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.mask" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.process" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.process">process</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.set_id" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.set_id">set_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.CleanUpSumUpCorrections"><code class="flex name class">
<span>class <span class="ident">CleanUpSumUpCorrections</span></span>
<span>(</span><span>sum_tag: str, mixed_up_summand: str, other_summand: str)</span>
</code></dt>
<dd>
<div class="desc"><p>it happens, that the values for Assets and AssetsNoncurrent
where mixed
up. example: 0001692981-19-000022
So instead of Assets = AssetsCurrent + AssetsNoncurrent
it matches AssetsNoncurrent = Assets + AssetsCurrent.</p>
<p>so the first parameter is the sum_tag, e.g. Assets
the mixed_up_summand is the name of the summand that was mixed with the sum_tag
the other_summand is the summand with the correct value, e.g. AssetsCurrent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CleanUpSumUpCorrections(Rule):
    &#34;&#34;&#34; it happens, that the values for Assets and AssetsNoncurrent
    where mixed  up. example: 0001692981-19-000022
    So instead of Assets = AssetsCurrent + AssetsNoncurrent
    it matches AssetsNoncurrent = Assets + AssetsCurrent.

    so the first parameter is the sum_tag, e.g. Assets
    the mixed_up_summand is the name of the summand that was mixed with the sum_tag
    the other_summand is the summand with the correct value, e.g. AssetsCurrent
    &#34;&#34;&#34;

    def __init__(self, sum_tag: str, mixed_up_summand: str, other_summand: str):
        self.sum_tag = sum_tag
        self.mixed_up_summand = mixed_up_summand
        self.other_summand = other_summand

    def get_target_tags(self) -&gt; List[str]:
        return [self.sum_tag, self.mixed_up_summand]

    def get_input_tags(self) -&gt; Set[str]:
        return {self.sum_tag, self.mixed_up_summand, self.other_summand}

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        return (df[self.mixed_up_summand] == df[self.sum_tag] + df[self.other_summand]) \
               &amp; (df[self.other_summand] &gt; 0)

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        mixed_up_values = df[self.mixed_up_summand].copy()
        df.loc[mask, self.mixed_up_summand] = df[self.sum_tag]
        df.loc[mask, self.sum_tag] = mixed_up_values

    def get_description(self) -&gt; str:
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.rule_framework.RuleEntity" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.CleanUpSumUpCorrections.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.apply" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_description" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_description">get_description</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_input_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags">get_target_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str">get_target_tags_str</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.mask" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.process" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.process">process</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.set_id" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.set_id">set_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule"><code class="flex name class">
<span>class <span class="ident">MissingSumRule</span></span>
<span>(</span><span>sum_name: str, summand_names: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>creates the sum in the sum_name column if all summand_names columnes have a value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingSumRule(Rule):
    &#34;&#34;&#34; creates the sum in the sum_name column if all summand_names columnes have a value&#34;&#34;&#34;

    def __init__(self, sum_name: str, summand_names: List[str]):
        self.sum_name = sum_name
        self.summand_names = summand_names

    def get_target_tags(self) -&gt; List[str]:
        return [self.sum_name]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name}
        result.update(self.summand_names)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum_name has to be not set and all summand_names have to be set
        mask = df[self.sum_name].isna()
        for summand_name in self.summand_names:
            mask = mask &amp; ~df[summand_name].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.sum_name] = df[self.summand_names].sum(axis=1)

    def get_description(self) -&gt; str:
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.rule_framework.RuleEntity" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSumRule.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.apply" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_description" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_description">get_description</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_input_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags">get_target_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str">get_target_tags_str</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.mask" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.process" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.process">process</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.set_id" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.set_id">set_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule"><code class="flex name class">
<span>class <span class="ident">MissingSummandRule</span></span>
<span>(</span><span>sum_name: str, missing_summand: str, existing_summands: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Base class to define a single rule</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingSummandRule(Rule):

    def __init__(self, sum_name: str, missing_summand: str, existing_summands: List[str]):
        self.sum_name = sum_name
        self.missing_summand = missing_summand
        self.existing_summands = existing_summands

    def get_target_tags(self) -&gt; List[str]:
        return [self.missing_summand]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_name, self.missing_summand}
        result.update(self.existing_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # sum and other_summands must be set, missing_summand must not be set
        mask = ~df[self.sum_name].isna()
        for summand_name in self.existing_summands:
            mask = mask &amp; ~df[summand_name].isna()
        mask = mask &amp; df[self.missing_summand].isna()
        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.missing_summand] = \
            df[self.sum_name] - df[self.existing_summands].sum(axis=1)

    def get_description(self) -&gt; str:
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.rule_framework.RuleEntity" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.apply" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_description" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_description">get_description</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_input_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags">get_target_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str">get_target_tags_str</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.mask" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.process" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.process">process</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.set_id" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.set_id">set_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor"><code class="flex name class">
<span>class <span class="ident">RuleProcessor</span></span>
<span>(</span><span>rule_tree: <a title="secfsdstools.f_standardize.rule_framework.RuleGroup" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleGroup">RuleGroup</a>, clean_up_rule_tree: <a title="secfsdstools.f_standardize.rule_framework.RuleGroup" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleGroup">RuleGroup</a>, validation_rules: List[<a title="secfsdstools.f_standardize.bs_standardize.ValidationRule" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule">ValidationRule</a>], iterations: int, main_tags: List[str], final_tags: List[str], filter_for_main_report: bool = True, invert_negated: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RuleProcessor:
    identifier_tags = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;]

    def __init__(self, rule_tree: RuleGroup, clean_up_rule_tree: RuleGroup,
                 validation_rules: List[ValidationRule],
                 iterations: int, main_tags: List[str], final_tags: List[str],
                 filter_for_main_report: bool = True, invert_negated: bool = True):
        self.rule_tree = rule_tree
        self.clean_up_rule_tree = clean_up_rule_tree
        self.validation_rules = validation_rules
        self.iterations = iterations
        self.main_tags = main_tags
        self.final_tags = final_tags
        self.filter_for_main_report = filter_for_main_report
        self.invert_negated = invert_negated

        self.final_col_order = self.identifier_tags + self.final_tags

        self.preprocess_dupliate_log_df: Optional[pd.DataFrame] = None
        self.log_df: Optional[pd.DataFrame] = None
        self.applied_rules_sum_df: Optional[pd.DataFrame] = None
        self.stats: Optional[pd.DataFrame] = None

    def get_ruletree_descriptions(self):
        # todo
        pass

    def process(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        all_input_tags = self.rule_tree.get_input_tags()

        relevant_df = \
            df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;uom&#39;, &#39;value&#39;, &#39;report&#39;, &#39;line&#39;,
                &#39;negating&#39;]][df.tag.isin(all_input_tags)]

        # preprocessing ..
        #  - deduplicate
        cpy_df = self._deduplicate(relevant_df).copy()

        #  - invert_negated
        if self.invert_negated:
            cpy_df.loc[cpy_df.negating == 1, &#39;value&#39;] = -cpy_df.value

        # pivot the table, so that the tags become columns
        # todo: folgende Zeile sollte nicht mehr notwendig sein, sobald alle Regeln implementiert sind
        expected_tags = all_input_tags.union(self.final_tags)
        pivot_df = self._pivot(df=cpy_df, expected_tags=expected_tags)

        if self.filter_for_main_report:
            pivot_df = self._filter_pivot_for_main_reports(pivot_df)

        pivot_df_index_cols = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;, &#39;uom&#39;]
        self.log_df = pivot_df[pivot_df_index_cols].copy()

        total_length = len(pivot_df)

        # calculate_pre_stats:
        pre_apply_df = pivot_df[self.final_col_order]
        self.pre_stats = self._calculate_stats(pivot_df=pre_apply_df)
        self.pre_stats.name = &#34;pre&#34;

        self.stats = pd.DataFrame(self.pre_stats)
        self.stats[&#39;pre_rel&#39;] = self.stats.pre / total_length

        self.stats = pd.DataFrame(self.pre_stats)

        for i in range(self.iterations):
            # set ids of the rules in the tree, use the iteration number as prefix
            self.rule_tree.set_id(parent_prefix=f&#34;{i}_&#34;)

            # apply the rule_tree
            self.rule_tree.process(df=pivot_df, log_df=self.log_df)

            self.post_stats = self._calculate_stats(pivot_df=pivot_df)
            self.post_stats.name = f&#34;post_{i}&#34;

            self.stats = self.stats.join(self.post_stats)
            self.stats[self.post_stats.name + &#39;_rel&#39;] = \
                self.stats[self.post_stats.name] / total_length
            self.stats[self.post_stats.name + &#39;_red&#39;] = \
                1 - (self.stats[self.post_stats.name] / self.stats.pre)

        # clean up rules
        self.clean_up_rule_tree.process(df=pivot_df, log_df=self.log_df)

        # calculate cleanup stats
        self.post_cleanup = self._calculate_stats(pivot_df=pivot_df)
        self.post_cleanup.name = &#34;cleanup&#34;
        self.stats = self.stats.join(self.post_cleanup)
        self.stats[self.post_cleanup.name + &#39;_rel&#39;] = \
            self.stats[self.post_cleanup.name] / total_length
        self.stats[self.post_cleanup.name + &#39;_red&#39;] = \
            1 - (self.stats[self.post_cleanup.name] / self.stats.pre)

        # create a meaningful order
        pivot_df = pivot_df[self.final_col_order].copy()

        # apply validation rules
        for validation_rule in self.validation_rules:
            validation_rule.validate(pivot_df)

        # caculate log_df summaries
        if self.log_df is not None:
            # filter for rule columns but making sure the order stays the same
            rule_columns = [x for x in self.log_df.columns if x not in pivot_df_index_cols]
            self.applied_rules_sum_df = self.log_df[rule_columns].sum()

        return pivot_df

    def _deduplicate(self, df: pd.DataFrame) -&gt; pd.DataFrame:
        # find duplicated entries
        # sometimes, only single tags are duplicated, however, there are also reports
        # where all tags of a report are duplicated, maybe due to a problem with processing
        duplicates_s = \
            df.duplicated([&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;uom&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;value&#39;])

        self.preprocess_dupliate_log_df = df[duplicates_s] \
            [[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;uom&#39;, &#39;version&#39;, &#39;ddate&#39;]].copy()

        return df[~duplicates_s]

    def _filter_pivot_for_main_reports(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        &#34;&#34;&#34; Some reports have more than one &#39;report number&#39; (column report) for a
            certain statement. Generally, the one with the most tags is the one to take.
            This method operates on the pivoted data and counts the none-values of the
            &#34;main columns&#34;. The main columns are the fields, that generally should be there.
             &#34;&#34;&#34;

        cpy_pivot_df = pivot_df.copy()

        cpy_pivot_df[&#39;nan_count&#39;] = cpy_pivot_df[self.main_tags].isna().sum(axis=1)
        cpy_pivot_df.sort_values([&#39;adsh&#39;, &#39;coreg&#39;, &#39;nan_count&#39;], inplace=True)
        cpy_pivot_df = cpy_pivot_df.groupby([&#39;adsh&#39;, &#39;coreg&#39;]).last()
        cpy_pivot_df.reset_index(inplace=True)
        return cpy_pivot_df

    def _calculate_stats(self, pivot_df: pd.DataFrame) -&gt; pd.DataFrame:
        return pivot_df[self.final_tags].isna().sum(axis=0)

    def _pivot(self, df: pd.DataFrame, expected_tags: Set[str]) -&gt; pd.DataFrame:
        # it is possible, that the same number appears multiple times in different lines,
        # therefore, duplicates have to be removed, otherwise pivot is not possible
        relevant_df = df[
            [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;tag&#39;, &#39;value&#39;, &#39;uom&#39;, &#39;ddate&#39;]].drop_duplicates()

        pivot_df = relevant_df.pivot(index=[&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;uom&#39;, &#39;ddate&#39;],
                                     columns=&#39;tag&#39;,
                                     values=&#39;value&#39;)
        pivot_df.reset_index(inplace=True)
        missing_cols = set(expected_tags) - set(pivot_df.columns)
        for missing_col in missing_cols:
            pivot_df[missing_col] = np.nan
        pivot_df[&#39;nan_count&#39;] = np.nan
        return pivot_df</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer">BalanceSheetStandardizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor.identifier_tags"><code class="name">var <span class="ident">identifier_tags</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor.get_ruletree_descriptions"><code class="name flex">
<span>def <span class="ident">get_ruletree_descriptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_ruletree_descriptions(self):
    # todo
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.RuleProcessor.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self, df: pd.DataFrame) -&gt; pd.DataFrame:
    all_input_tags = self.rule_tree.get_input_tags()

    relevant_df = \
        df[[&#39;adsh&#39;, &#39;coreg&#39;, &#39;tag&#39;, &#39;version&#39;, &#39;ddate&#39;, &#39;uom&#39;, &#39;value&#39;, &#39;report&#39;, &#39;line&#39;,
            &#39;negating&#39;]][df.tag.isin(all_input_tags)]

    # preprocessing ..
    #  - deduplicate
    cpy_df = self._deduplicate(relevant_df).copy()

    #  - invert_negated
    if self.invert_negated:
        cpy_df.loc[cpy_df.negating == 1, &#39;value&#39;] = -cpy_df.value

    # pivot the table, so that the tags become columns
    # todo: folgende Zeile sollte nicht mehr notwendig sein, sobald alle Regeln implementiert sind
    expected_tags = all_input_tags.union(self.final_tags)
    pivot_df = self._pivot(df=cpy_df, expected_tags=expected_tags)

    if self.filter_for_main_report:
        pivot_df = self._filter_pivot_for_main_reports(pivot_df)

    pivot_df_index_cols = [&#39;adsh&#39;, &#39;coreg&#39;, &#39;report&#39;, &#39;ddate&#39;, &#39;uom&#39;]
    self.log_df = pivot_df[pivot_df_index_cols].copy()

    total_length = len(pivot_df)

    # calculate_pre_stats:
    pre_apply_df = pivot_df[self.final_col_order]
    self.pre_stats = self._calculate_stats(pivot_df=pre_apply_df)
    self.pre_stats.name = &#34;pre&#34;

    self.stats = pd.DataFrame(self.pre_stats)
    self.stats[&#39;pre_rel&#39;] = self.stats.pre / total_length

    self.stats = pd.DataFrame(self.pre_stats)

    for i in range(self.iterations):
        # set ids of the rules in the tree, use the iteration number as prefix
        self.rule_tree.set_id(parent_prefix=f&#34;{i}_&#34;)

        # apply the rule_tree
        self.rule_tree.process(df=pivot_df, log_df=self.log_df)

        self.post_stats = self._calculate_stats(pivot_df=pivot_df)
        self.post_stats.name = f&#34;post_{i}&#34;

        self.stats = self.stats.join(self.post_stats)
        self.stats[self.post_stats.name + &#39;_rel&#39;] = \
            self.stats[self.post_stats.name] / total_length
        self.stats[self.post_stats.name + &#39;_red&#39;] = \
            1 - (self.stats[self.post_stats.name] / self.stats.pre)

    # clean up rules
    self.clean_up_rule_tree.process(df=pivot_df, log_df=self.log_df)

    # calculate cleanup stats
    self.post_cleanup = self._calculate_stats(pivot_df=pivot_df)
    self.post_cleanup.name = &#34;cleanup&#34;
    self.stats = self.stats.join(self.post_cleanup)
    self.stats[self.post_cleanup.name + &#39;_rel&#39;] = \
        self.stats[self.post_cleanup.name] / total_length
    self.stats[self.post_cleanup.name + &#39;_red&#39;] = \
        1 - (self.stats[self.post_cleanup.name] / self.stats.pre)

    # create a meaningful order
    pivot_df = pivot_df[self.final_col_order].copy()

    # apply validation rules
    for validation_rule in self.validation_rules:
        validation_rule.validate(pivot_df)

    # caculate log_df summaries
    if self.log_df is not None:
        # filter for rule columns but making sure the order stays the same
        rule_columns = [x for x in self.log_df.columns if x not in pivot_df_index_cols]
        self.applied_rules_sum_df = self.log_df[rule_columns].sum()

    return pivot_df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SetSumIfOneOnlySummand"><code class="flex name class">
<span>class <span class="ident">SetSumIfOneOnlySummand</span></span>
<span>(</span><span>sum_tag: str, summand_set: str, summands_nan: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>If the sumt_tag is nan and only one summand has a value, then the
target gets the copy of the Value and the other summands are set to zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SetSumIfOneOnlySummand(Rule):
    &#34;&#34;&#34;
    If the sumt_tag is nan and only one summand has a value, then the
    target gets the copy of the Value and the other summands are set to zero.
    &#34;&#34;&#34;

    def __init__(self, sum_tag: str, summand_set: str, summands_nan: List[str]):
        self.sum_tag = sum_tag
        self.summand_set = summand_set
        self.summands_nan = summands_nan

    def get_target_tags(self) -&gt; List[str]:
        return [self.sum_tag, *self.summands_nan]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.sum_tag, self.summand_set}
        result.update(self.summands_nan)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the target was not set..

        mask = df[self.sum_tag].isna() &amp; ~df[self.summand_set].isna()
        for summand_nan in self.summands_nan:
            mask = mask &amp; df[summand_nan].isna()

        return mask

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.sum_tag] = df[self.summand_set]  # initialize
        for summand_nan in self.summands_nan:
            df.loc[mask, summand_nan] = 0.0

    def get_description(self) -&gt; str:
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.rule_framework.RuleEntity" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.SetSumIfOneOnlySummand.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.apply" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_description" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_description">get_description</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_input_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags">get_target_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str">get_target_tags_str</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.mask" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.process" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.process">process</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.set_id" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.set_id">set_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator"><code class="flex name class">
<span>class <span class="ident">SumCompletionRuleGroupCreator</span></span>
</code></dt>
<dd>
<div class="desc"><p>completes the missing value of a simple addition, if one is missing.
E.G Assets = AssetsCurrent + AssetsNoneCurrent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SumCompletionRuleGroupCreator:
    &#34;&#34;&#34;
    completes the missing value of a simple addition, if one is missing.
    E.G Assets = AssetsCurrent + AssetsNoneCurrent
    &#34;&#34;&#34;

    @staticmethod
    def create_group(sum_tag: str, summand_tags: List[str], prefix: str) -&gt; RuleGroup:
        rules: List[RuleEntity] = [MissingSumRule(sum_name=sum_tag,
                                                  summand_names=summand_tags)]
        for summand in summand_tags:
            others = summand_tags.copy()
            others.remove(summand)
            rules.append(MissingSummandRule(sum_name=sum_tag, missing_summand=summand,
                                            existing_summands=others))
        return RuleGroup(rules=rules, prefix=prefix)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator.create_group"><code class="name flex">
<span>def <span class="ident">create_group</span></span>(<span>sum_tag: str, summand_tags: List[str], prefix: str) ‑> <a title="secfsdstools.f_standardize.rule_framework.RuleGroup" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleGroup">RuleGroup</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_group(sum_tag: str, summand_tags: List[str], prefix: str) -&gt; RuleGroup:
    rules: List[RuleEntity] = [MissingSumRule(sum_name=sum_tag,
                                              summand_names=summand_tags)]
    for summand in summand_tags:
        others = summand_tags.copy()
        others.remove(summand)
        rules.append(MissingSummandRule(sum_name=sum_tag, missing_summand=summand,
                                        existing_summands=others))
    return RuleGroup(rules=rules, prefix=prefix)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp"><code class="flex name class">
<span>class <span class="ident">SumUp</span></span>
<span>(</span><span>target: str, potential_summands: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Sums app the available Summands to a new target column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SumUp(Rule):
    &#34;&#34;&#34;Sums app the available Summands to a new target column&#34;&#34;&#34;

    def __init__(self, target: str, potential_summands: List[str]):
        self.target = target
        self.potential_summands = potential_summands

    def get_target_tags(self) -&gt; List[str]:
        return [self.target]

    def get_input_tags(self) -&gt; Set[str]:
        result = {self.target}
        result.update(self.potential_summands)
        return result

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        # if the target was not set..
        return df[self.target].isna()

    def apply(self, df: pd.DataFrame, mask: pa.typing.Series[bool]):
        df.loc[mask, self.target] = 0.0  # initialize
        for potential_summand in self.potential_summands:
            summand_mask = mask &amp; ~df[potential_summand].isna()
            df.loc[summand_mask, self.target] = df[self.target] + df[potential_summand]

    def get_description(self) -&gt; str:
        return &#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></li>
<li><a title="secfsdstools.f_standardize.rule_framework.RuleEntity" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity">RuleEntity</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.SumUp.id"><code class="name">var <span class="ident">id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.f_standardize.rule_framework.Rule" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule">Rule</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.apply" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.apply">apply</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_description" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_description">get_description</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_input_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.get_input_tags">get_input_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags">get_target_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.get_target_tags_str">get_target_tags_str</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.mask" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.process" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.Rule.process">process</a></code></li>
<li><code><a title="secfsdstools.f_standardize.rule_framework.Rule.set_id" href="rule_framework.html#secfsdstools.f_standardize.rule_framework.RuleEntity.set_id">set_id</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumValidationRule"><code class="flex name class">
<span>class <span class="ident">SumValidationRule</span></span>
<span>(</span><span>id: str, sum_tag: str, summands: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SumValidationRule(ValidationRule):

    def __init__(self, id: str, sum_tag: str, summands: List[str]):
        super().__init__(id)
        self.sum_tag = sum_tag
        self.summands = summands

    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        mask = ~df[self.sum_tag].isna()
        for summand in self.summands:
            mask = mask &amp; ~df[summand].isna()

        return mask

    def calculate_error(self, df: pd.DataFrame, mask: pa.typing.Series[bool]) -&gt; \
            pa.typing.Series[np.float64]:
        return ((df[self.sum_tag] - df[self.summands].sum(axis=&#39;columns&#39;)) / df[self.sum_tag]).abs()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.ValidationRule" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule">ValidationRule</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.SumValidationRule.calculate_error"><code class="name flex">
<span>def <span class="ident">calculate_error</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool]) ‑> pandera.typing.pandas.Series[numpy.float64]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_error(self, df: pd.DataFrame, mask: pa.typing.Series[bool]) -&gt; \
        pa.typing.Series[np.float64]:
    return ((df[self.sum_tag] - df[self.summands].sum(axis=&#39;columns&#39;)) / df[self.sum_tag]).abs()</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.SumValidationRule.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    mask = ~df[self.sum_tag].isna()
    for summand in self.summands:
        mask = mask &amp; ~df[summand].isna()

    return mask</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.ValidationRule"><code class="flex name class">
<span>class <span class="ident">ValidationRule</span></span>
<span>(</span><span>id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ValidationRule(ABC):

    def __init__(self, id: str):
        self.id = id

    @abstractmethod
    def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
        pass

    @abstractmethod
    def calculate_error(self, df: pd.DataFrame, mask: pa.typing.Series[bool]) -&gt; \
            pa.typing.Series[np.float64]:
        pass

    def validate(self, df: pd.DataFrame):
        mask = self.mask(df)
        error = self.calculate_error(df, mask)

        error_column_name = f&#39;{self.id}_error&#39;
        cat_column_name = f&#39;{self.id}_cat&#39;

        df[error_column_name] = None
        df.loc[mask, error_column_name] = error

        df.loc[mask, cat_column_name] = 100  # gt &gt; 0.1 / 10%
        df.loc[df[error_column_name] &lt;= 0.1, cat_column_name] = 10  # 5-10 %
        df.loc[df[error_column_name] &lt;= 0.05, cat_column_name] = 5  # 1-5 %
        df.loc[df[error_column_name] &lt;= 0.01, cat_column_name] = 1  # &lt; 1%
        df.loc[df[error_column_name] == 0.0, cat_column_name] = 0  # exact match</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.f_standardize.bs_standardize.SumValidationRule" href="#secfsdstools.f_standardize.bs_standardize.SumValidationRule">SumValidationRule</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.f_standardize.bs_standardize.ValidationRule.calculate_error"><code class="name flex">
<span>def <span class="ident">calculate_error</span></span>(<span>self, df: pandas.core.frame.DataFrame, mask: pandera.typing.pandas.Series[bool]) ‑> pandera.typing.pandas.Series[numpy.float64]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate_error(self, df: pd.DataFrame, mask: pa.typing.Series[bool]) -&gt; \
        pa.typing.Series[np.float64]:
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.ValidationRule.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self, df: pandas.core.frame.DataFrame) ‑> pandera.typing.pandas.Series[bool]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def mask(self, df: pd.DataFrame) -&gt; pa.typing.Series[bool]:
    pass</code></pre>
</details>
</dd>
<dt id="secfsdstools.f_standardize.bs_standardize.ValidationRule.validate"><code class="name flex">
<span>def <span class="ident">validate</span></span>(<span>self, df: pandas.core.frame.DataFrame)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate(self, df: pd.DataFrame):
    mask = self.mask(df)
    error = self.calculate_error(df, mask)

    error_column_name = f&#39;{self.id}_error&#39;
    cat_column_name = f&#39;{self.id}_cat&#39;

    df[error_column_name] = None
    df.loc[mask, error_column_name] = error

    df.loc[mask, cat_column_name] = 100  # gt &gt; 0.1 / 10%
    df.loc[df[error_column_name] &lt;= 0.1, cat_column_name] = 10  # 5-10 %
    df.loc[df[error_column_name] &lt;= 0.05, cat_column_name] = 5  # 1-5 %
    df.loc[df[error_column_name] &lt;= 0.01, cat_column_name] = 1  # &lt; 1%
    df.loc[df[error_column_name] == 0.0, cat_column_name] = 0  # exact match</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="secfsdstools.f_standardize" href="index.html">secfsdstools.f_standardize</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer">BalanceSheetStandardizer</a></code></h4>
<ul class="two-column">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_rename_rg" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_rename_rg">bs_rename_rg</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sum_completion" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sum_completion">bs_sum_completion</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sumup_rg" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.bs_sumup_rg">bs_sumup_rg</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.cleanup_rule_tree" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.cleanup_rule_tree">cleanup_rule_tree</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.final_tags" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.final_tags">final_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.main_tags" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.main_tags">main_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.rule_tree" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.rule_tree">rule_tree</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.validation_rules" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizer.validation_rules">validation_rules</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld">BalanceSheetStandardizerOld</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.complete_special_rules" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.complete_special_rules">complete_special_rules</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.fill_still_isna_summands" href="#secfsdstools.f_standardize.bs_standardize.BalanceSheetStandardizerOld.fill_still_isna_summands">fill_still_isna_summands</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.CleanUpCopyToFirstSummand" href="#secfsdstools.f_standardize.bs_standardize.CleanUpCopyToFirstSummand">CleanUpCopyToFirstSummand</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.CleanUpCopyToFirstSummand.id" href="#secfsdstools.f_standardize.bs_standardize.CleanUpCopyToFirstSummand.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.CleanUpSumUpCorrections" href="#secfsdstools.f_standardize.bs_standardize.CleanUpSumUpCorrections">CleanUpSumUpCorrections</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.CleanUpSumUpCorrections.id" href="#secfsdstools.f_standardize.bs_standardize.CleanUpSumUpCorrections.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule">MissingSumRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSumRule.id" href="#secfsdstools.f_standardize.bs_standardize.MissingSumRule.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule">MissingSummandRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.MissingSummandRule.id" href="#secfsdstools.f_standardize.bs_standardize.MissingSummandRule.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor">RuleProcessor</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor.get_ruletree_descriptions" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor.get_ruletree_descriptions">get_ruletree_descriptions</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor.identifier_tags" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor.identifier_tags">identifier_tags</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.RuleProcessor.process" href="#secfsdstools.f_standardize.bs_standardize.RuleProcessor.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.SetSumIfOneOnlySummand" href="#secfsdstools.f_standardize.bs_standardize.SetSumIfOneOnlySummand">SetSumIfOneOnlySummand</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SetSumIfOneOnlySummand.id" href="#secfsdstools.f_standardize.bs_standardize.SetSumIfOneOnlySummand.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator" href="#secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator">SumCompletionRuleGroupCreator</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator.create_group" href="#secfsdstools.f_standardize.bs_standardize.SumCompletionRuleGroupCreator.create_group">create_group</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp" href="#secfsdstools.f_standardize.bs_standardize.SumUp">SumUp</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumUp.id" href="#secfsdstools.f_standardize.bs_standardize.SumUp.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.SumValidationRule" href="#secfsdstools.f_standardize.bs_standardize.SumValidationRule">SumValidationRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumValidationRule.calculate_error" href="#secfsdstools.f_standardize.bs_standardize.SumValidationRule.calculate_error">calculate_error</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.SumValidationRule.mask" href="#secfsdstools.f_standardize.bs_standardize.SumValidationRule.mask">mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.f_standardize.bs_standardize.ValidationRule" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule">ValidationRule</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.f_standardize.bs_standardize.ValidationRule.calculate_error" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule.calculate_error">calculate_error</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.ValidationRule.mask" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule.mask">mask</a></code></li>
<li><code><a title="secfsdstools.f_standardize.bs_standardize.ValidationRule.validate" href="#secfsdstools.f_standardize.bs_standardize.ValidationRule.validate">validate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>