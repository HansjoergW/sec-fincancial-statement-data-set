Fragen:
- standard Framework verwenden, dass auch bereits parallelisierung beherrscht? -> Nein
- Alle Prozessschritte in Pipelines umwandeln, oder kann download z.B. belassen wie es ist? -> Ja
- Wie mit quarterly und daily umgehen? -> Im Moment wie gehabt

- Wie wird der Status gemanaged? Immer über Files, oder doch besser über eine Tabelle?
  -> Vorteil File -> der Ist Zustand ist immer korrekt
  -> Vorteil Status in Tabelle -> Abfrage ist immer identisch
- Wie machen wir das ganze robust / Fehlerbehandlung
  -> Wie wird geprüft, ob ein Schritt für einen Teil tatsächlich ausgeführt wurde
     -> Z.B. welche Files müssen vorhanden sein.
- Steps eines Tasks
  - calculate_tasks -> bestimmen, für welche Teile (zip-files) Tasks überhaupt erstellt werden muss
  - pro Task
    - prepare -> Verzeichnis estellen/vorhandenes löschen
    - do -> Schritt ausführen
    - commit -> irgendwie bestätigen, dass Task vollendet ist
    - finish (z.B. entfernen von zip files -> müsste aber im Transform gemacht werden
    - exception -> cleanup

- Performance Optimierung ist nicht wirklich das Thema, da die Logik nur einmal pro Quartal läuft

Schritte

- einfachste Variante:
  -> eine simple Hook Methode
- kleines Framework

- Hinzufügen von customer Schritten

Umbau von CheckForNewData
- müsste eigentlich im init-py vom Root Modul gemacht werden, so dass diese Logik immer läuft
  - dort könnte man einfach getconfiguration callen und dann den check ausführen
  - Vorteil -> check wird immer gemacht
  - Nachteil: wenn das aber so gemacht wird, dann ist die Frage, wie eigene Tasks registriert werden können.
              das wäre dann eigentlich immer zu spät, ausser man macht das über das setup py
              oder wir managen eigene Tasks separat -> eigenr check, ob sie ausgeführt werden müssen, oder nicht

    def call_function_from_string(module_function_str):

        try:
            module_str, function_str = module_function_str.rsplit('.', 1)
            module = importlib.import_module(module_str)
            function = getattr(module, function_str)
            return function()
        except ModuleNotFoundError:
            print(f"Module {module_str} not found.")
        except AttributeError:
            print(f"Function {function_str} not found in module {module_str}.")
- configparser.ConfigParser ist teil von Configuration, falls configfile geladen wurde
  -> müsste als Parameter bei der callback funktion übergeben werden.

Struktur
--------

1. Version / Idee

data/dld
data/parquet
data/filter/

   /quarter/<zipname>
       /raw /BS
            /IS
            /CF
            /CP
            /CI
            /..
       /joined /BS
            /IS
            /CF
            /CP
            /CI
            /..

   all
        /raw /BS
             /..
        /joined /BS
                /..

data/standardized/quarter/
    <zipname>/BS
             /IS
             /CF
    all      /BS
             /IS
             /CF

    allcombined

data/standardizedcombined

Ticker symbols
outstanding shares / EPS_calc


2. Version

data/dld
data/parquet
data/filtered_raw/

   /quarter/<zipname>
       /raw
       /joined

   all
        /raw
        /joined

data/standardized/quarter/
    <zipname>/BS
             /IS
             /CF
    all      /BS
             /IS
             /CF

    allcombined

data/standardizedcombined

Ticker symbols
outstanding shares / EPS_calc


3. Version
- Es braucht eine Variante, in der zuerst nach statement gefiltert wird, und zwar einzeln,
  und dann die all dateien pro stmt erzeugt werden
  -> Problem ist, dass Memory Verbrauch sonst für viele vermutlich zu hoch sein wird.

_filtered_joined_by_stmt/
  -> problem ist, dass wir in dem Fall pro stmt laden, was nicht sehr effizient ist
     ansonsten funktionert die aktuelly "combine" nicht, da wir immer davon ausgehen,
     dass die letzte Stufe den namen definiert

     vlt wäre es der bessera Ansatz die Combine Methode anzupassen -> sprich einen hint for "filename"
     evtl. eine zweiten Filter
     dann könnte man wieder mit quarter/<zipname/tempzipname>/stmt arbeiten..

  quarter/<stmt>/<zipname>

  all/<stmt>/


Final Target
------------
  _1_filtered_raw
     quarter
       2009q2.zip
       ...
     all   -> memory intensiv

  _1_filtered_joined
     quarter
       2009q2.zip
          BS
          IS
          CF
          ...
       ...
     all_by_stmt
       BS
       IS
       CF
       ...
     all



