<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>secfsdstools.c_automation.task_framework API documentation</title>
<meta name="description" content="Base classes for the Task and Process Framework.
Used for downloading, transforming to parquet, and indexing of the zip files from SEC, as well
as to â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>secfsdstools.c_automation.task_framework</code></h1>
</header>
<section id="section-intro">
<p>Base classes for the Task and Process Framework.
Used for downloading, transforming to parquet, and indexing of the zip files from SEC, as well
as to implement customized automation tasks.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Base classes for the Task and Process Framework.
Used for downloading, transforming to parquet, and indexing of the zip files from SEC, as well
as to implement customized automation tasks.
&#34;&#34;&#34;

import logging
import shutil
from abc import ABC, abstractmethod
from collections import defaultdict
from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Protocol, Tuple

from secfsdstools.a_utils.parallelexecution import ParallelExecutor, ThreadExecutor
from secfsdstools.c_automation.automation_utils import get_latest_mtime


class TaskResultState(Enum):
    &#34;&#34;&#34;
    Enum defining possible ResultStates of one task.
    &#34;&#34;&#34;

    SUCCESS = 1
    FAILED = 2


class Task(Protocol):
    &#34;&#34;&#34;
    Task interface.
    &#34;&#34;&#34;

    def prepare(self):
        &#34;&#34;&#34;Prepare everything to execute the task.
        E.g., creation or clearing a directory.&#34;&#34;&#34;

    def execute(self):
        &#34;&#34;&#34;Execution the task.&#34;&#34;&#34;

    def commit(self) -&gt; Any:
        &#34;&#34;&#34;Commit the task if the execution method is not &#34;self-commiting&#34;. E.g.,
        If you do some file processing in the execute-method,
        but want to update a state in a table,
        you could do the update of the state in the commit method.
        &#34;&#34;&#34;

    def exception(self, exception) -&gt; Any:
        &#34;&#34;&#34;Handle the exception.&#34;&#34;&#34;


@dataclass
class TaskResult:
    &#34;&#34;&#34;
    Dataclass containing the result of a task.
    Contains the task, the TaskResultState and the result (either the return value form the commit()
    or exception() method.
    &#34;&#34;&#34;

    task: Task
    result: Any
    state: TaskResultState


class AbstractTask:
    &#34;&#34;&#34;
    Abstract Base implemenation providing some commonly used basic functionality.

    It is based on reading subfolders from a root_path, which are defined by pathfilter.
    Then processing the content of these folders and writing the result in a target_path.

    The result is created in tmp-folder and is then &#34;commited&#34; by renaming the tmp-folder into
    the target-path, therefore providing an atomic-action (renaming) that acts as commit.

    It also provides basic implementation of &#34;meta.inf&#34; file, that can be stored in the target.
    The idea of the meta.inf file is, to give a hint of what already was processed from the
    root_path in a previous, step.

    For example, the meta.inf could contain a list of subfolder names that were already processed.
    Therefore, if a new subfolder appears in the root_path, the task would knwow which subfolders
    need to be process. another possibility is to store the timestamp of the data, which was
    processed (in cases, where the content of files within the subfolders in root_path changes, but
    not the subfolders themselves). Therefore, allowing to check whether a modification timestamp
    of files in the root_path is newer than the timestamp stored in the meta.inf file.

    &#34;&#34;&#34;

    def __init__(self, root_paths: List[Path], pathfilter: str, target_path: Path):
        &#34;&#34;&#34;
        The constructor of the AbstracTask.

        Args:
            root_paths: list of root_paths of the data to be processed
            pathfilter: a pathfilter string (e.g. &#34;*&#34;; as defined for Path.glob()) to select the
                    subfolders in the root_paths, that have to be processed.
                    pathfilter could be something like &#34;*&#34;, or &#34;*/BS&#34;, or &#34;something/*/BS&#34;.

                    E.g., the following root_path structure and the pathfilter &#34;*/BS&#34;
                    would select all &#34;BS&#34; &#34;sub-subfolders&#34; within root_path:
                    &lt;pre&gt;
                       &lt;root_path&gt;
                            2010a1.zip/BS
                            2010q1.zip/IS
                            2010q1.zip/CF
                            ...
                            2024a4.zip/BS
                            2024q4.zip/IS
                            2024q4.zip/CF
                    &lt;/pre&gt;

            target_path: the target_path to write the results to.
        &#34;&#34;&#34;

        self.root_paths = root_paths
        self.target_path = target_path
        self.filter = pathfilter

        self.filtered_paths: List[Path] = []

        if self.filter is None or self.filter == &#34;&#34;:
            self.filtered_paths.extend(self.root_paths)
        else:
            for root_path in root_paths:
                self.filtered_paths.extend(list(root_path.glob(self.filter)))

        # usually, all filtered_paths have to be processed
        self.paths_to_process: List[Path] = self.filtered_paths

        # define the tmp_path
        self.tmp_path = target_path.parent / f&#34;tmp_{target_path.name}&#34;
        self.meta_inf_file: Path = self.target_path / &#34;meta.inf&#34;

        # pathfilter could be something like &#34;*&#34;, or &#34;*/BS&#34;, or &#34;something/*/BS&#34;
        # but in order to be able to fill the metainf file with the names for which &#34;*&#34; iterates
        # over, we need to know the position of the &#34;*&#34; from the end of the resulting path.
        # So if the pathfilter is just a &#34;*&#34; it is 0, if it is &#34;*/BS&#34; it would be 1
        self.star_position = self._star_position_from_end(self.filter)

    @staticmethod
    def _star_position_from_end(path: str) -&gt; int:
        &#34;&#34;&#34;
        Gets the position of the &#34;*&#34; in the provided path (counted from the end).

        Examples:
            path = &#34;a/b/c/d/*&#34; -&gt; returns 0
            path = &#34;a/b/c/*/d&#34; -&gt; returns 1
            path = &#34;a/b/*/c/d&#34; -&gt; returns 2

        Args:
            path: path with a &#34;*&#34; as part

        Returns:
            the position of the &#34;*&#34; in the path, counted from the end.
        &#34;&#34;&#34;

        # ignore first and last /
        if path.startswith(&#34;/&#34;):
            path = path[1:]
        if path.endswith(&#34;/&#34;):
            path = path[:-1]

        # Split the string by &#39;/&#39; to get segments
        segments = path.split(&#34;/&#34;)

        # Iterate from the end and find the first segment containing &#39;*&#39;
        for i, segment in enumerate(reversed(segments)):
            if &#34;*&#34; in segment:
                return i  # Position from the end

        # If no &#39;*&#39; is found, return -1 to indicate an error
        return -1

    @staticmethod
    def _get_star_position_name(path: Path, star_position: int) -&gt; str:
        &#34;&#34;&#34;
        Gets the name of the part where the &#34;*&#34; is positioned in the pathfilter-string.

        Example:
             path = &#34;a/b/c&#34; and star_position = 0 -&gt; returns c
             path = &#34;a/b/c&#34; and star_position = 1 -&gt; returns b
             path = &#34;a/b/c&#34; and star_position = 2 -&gt; returns c

        Args:
            path: path from which the name_part at the star_position has to be returned
            star_position: position of the part which name has to be returned.

        Returns:
            str: name of the part defined by the star_position

        &#34;&#34;&#34;
        # reverse list with [::-1]
        return path.parts[::-1][star_position]

    def read_metainf_content(self) -&gt; List[str]:
        &#34;&#34;&#34;
        reads the content from the meta.inf file in an existing target_path
        Returns:
            List(str): the content by line
        &#34;&#34;&#34;
        meta_inf_content = self.meta_inf_file.read_text(encoding=&#34;utf-8&#34;)
        return meta_inf_content.split(&#34;\n&#34;)

    def exception(self, exception) -&gt; str:
        &#34;&#34;&#34;
        Basic implementation of the exception method.
        It deletes the temp folder and returns a &#34;failed&#34; message.
        &#34;&#34;&#34;
        shutil.rmtree(self.tmp_path, ignore_errors=True)
        return f&#34;failed {exception}&#34;

    def has_work_todo(self) -&gt; bool:
        &#34;&#34;&#34;
        returns true if there is actual work to do, otherwise False.
        Can be overwritten.
        Default implementation just looks if the provided root_path has subfolders, that are
        defined by the provided pathfilter string.
        &#34;&#34;&#34;
        return len(self.paths_to_process) &gt; 0

    def prepare(self):
        &#34;&#34;&#34;
        basic implementation of the prepare method. Does nothing if there is nothing to process
        or does create the tmp_folder, if processing has to be done.
        &#34;&#34;&#34;
        if not self.has_work_todo():
            return

        self.tmp_path.mkdir(parents=True, exist_ok=False)

    def commit(self):
        &#34;&#34;&#34;
        Basic implementation of the commit method.
        If nothing had to be done, it simply returns &#34;success&#34;.
        If work was done, it removes an existing target_path, and overwrites it with the
        content of the tmp_path (by renaming the tmp_path to the target_path, which is an
        atomic action, which either fails, or succeeds).
        &#34;&#34;&#34;
        if not self.has_work_todo():
            return &#34;success&#34;

        # Remove old content of target_path
        if self.target_path.exists():
            shutil.rmtree(self.target_path)

        # rename the tmp_path, so this is like an atomic action that either fails or succeeds.
        self.tmp_path.rename(self.target_path)
        return &#34;success&#34;

    def write_meta_inf(self, content: str):
        &#34;&#34;&#34;
        writes the provided content into the the meta_inf file in the tmp-path.
        Args:
            content: content to be written
        &#34;&#34;&#34;
        temp_meta_inf = self.tmp_path / &#34;meta.inf&#34;
        temp_meta_inf.write_text(data=content, encoding=&#34;utf-8&#34;)


class CheckByTimestampMergeBaseTask(AbstractTask):
    &#34;&#34;&#34;
    This class uses the AbstractTask to implement logic that checks if files were changed within
    the root_path since the last processing.

    It can be used as a BaseClass to implement a Task, that checks for new data to be processed
    by looking at the modification timestamp of the files in the root_path.

    It does this as follows:
    - if there is no target_path yet, it will process the content in the root_path,
      write the result in the target_path together with a meta.inf file that contains
      the newest modification timestamp of all the files in the root_path.
    - if there is a target_path, then it reads the timestamp, that is stored within the target_path.
      It any of the files within the root_path has a newer modification timestamp, it will
      process the data and also update the timestamp in the meta.inf file
    &#34;&#34;&#34;

    def __init__(self, root_paths: List[Path], pathfilter: str, target_path: Path):
        &#34;&#34;&#34;
        The constructor of the CheckByTimestampMergeBaseTask.
        Check also the documentation of the AbstractTask Constructor.
        &#34;&#34;&#34;
        super().__init__(root_paths=root_paths, pathfilter=pathfilter, target_path=target_path)

        if self.meta_inf_file.exists():
            # if the meta_inf file exists, we expect that the first row contains the
            # latest modification timestamp of all files in the root_path, that was
            # processed the last time.
            containing_values = self.read_metainf_content()
            last_processed_timestamp = float(containing_values[0])

            # go and find the current latest modification timestamp of allfiles in the root_path
            current_timestamp = get_latest_mtime(self.root_paths)

            # if the current_timestamp is equal to the last_processed_timestamp,
            # it means that the data in the root_path weren&#39;t changed and therefore,
            # no processing has to be done. We mark this by setting pats_to_process to an empty list
            if current_timestamp &lt;= last_processed_timestamp:
                self.paths_to_process = []

    def execute(self):
        &#34;&#34;&#34;
        Basic implementation of the execute method.

        If there are &#34;paths_to_process&#34;, what has to be done depending on &#34;check_by_timestamp&#34;
        being true or not.

        Returns:

        &#34;&#34;&#34;
        if not self.has_work_todo():
            return

        self.do_execution(paths_to_process=self.paths_to_process, tmp_path=self.tmp_path)

        meta_inf_content: str = str(get_latest_mtime(self.root_paths))
        self.write_meta_inf(content=meta_inf_content)

    @abstractmethod
    def do_execution(self, paths_to_process: List[Path], tmp_path: Path):
        &#34;&#34;&#34;
            defines the logic to be executed.
        Args:
            paths_to_process: lists of paths/folders that have to be processed
            tmp_path: path to where a result has to be written
        &#34;&#34;&#34;


class CheckByNewSubfoldersMergeBaseTask(AbstractTask):
    &#34;&#34;&#34;
    Implements the basic logic to track already processed data either by folder structure of the
    root-path (meaning that new data that appeared as a new subfolder in the root-path has to be
    integrated in the existing content of the target path) or by
    checking the timestamp of the latest modifications within the root-path structure (meaning
    that the content of the target-path has to be recreated with the current content of the
    root-path.

    Both scenarios use a &#34;meta-inf&#34; file that either contains the name of the subfolders, or the
    the timestamp of the latest processed modification.
    &#34;&#34;&#34;

    def __init__(self, root_paths: List[Path], pathfilter: str, target_path: Path):
        &#34;&#34;&#34;
        Constructor of base task.

        Args:
            root_paths: root paths to read data from
            pathfilter: pathfilter string that defines which subfolders in the
                        root_path have to be selected
            target_path: path to where the results have to be written
        &#34;&#34;&#34;
        self.all_names: Dict[str, Path]

        super().__init__(
            root_paths=root_paths,
            pathfilter=pathfilter,
            target_path=target_path,
        )

        # so if we have the pathfilter */BS and if we have the directories &#34;2010q1.zip/BS&#34;,
        # &#34;2010q2.zip/BS&#34; in the root_path, all_names key will be 2010q1.zip, 2010q2.zip
        self.all_names = {
            self._get_star_position_name(path=p, star_position=self.star_position): p for p in self.paths_to_process
        }

        if self.meta_inf_file.exists():
            containing_values = self.read_metainf_content()

            missing = set(self.all_names.keys()) - set(containing_values)
            self.paths_to_process = [self.all_names[name] for name in missing]

    def execute(self):
        &#34;&#34;&#34;
        Basic implementation of the execute method.

        If there are &#34;paths_to_process&#34;, what has to be done depending on &#34;check_by_timestamp&#34;
        being true or not.


        Returns:

        &#34;&#34;&#34;
        if len(self.paths_to_process) == 0:
            return

        paths_to_process = self.paths_to_process.copy()

        # depending on the use case, we need to combine new data with already
        # existing data in the target.
        # therefore, we provide a list &#34;paths_to_process&#34; which contains subfolders that are new,
        # the processed_path (the path that contains the result of the last processing), and
        # the target_path, where we have to store the result to (this the tmp folder)
        self.do_execution(paths_to_process=paths_to_process, target_path=self.target_path, tmp_path=self.tmp_path)

        meta_inf_content: str = &#34;\n&#34;.join(
            [self._get_star_position_name(f, self.star_position) for f in self.filtered_paths]
        )
        self.write_meta_inf(content=meta_inf_content)

    @abstractmethod
    def do_execution(self, paths_to_process: List[Path], target_path: Path, tmp_path: Path):
        &#34;&#34;&#34;
            defines the logic to be executed.
        Args:
            paths_to_process: lists of paths/folders that have to be processed
            target_path: the path where the result of the previous run was written
            tmp_path: target path to where a result has to be written
        &#34;&#34;&#34;


class AbstractProcess(ABC):
    &#34;&#34;&#34;
    Defines the Abstract process of processing tasks for a certain process.
    &#34;&#34;&#34;

    @abstractmethod
    def process(self):
        &#34;&#34;&#34;executes the process.&#34;&#34;&#34;


class AbstractParallelProcess(AbstractProcess):
    &#34;&#34;&#34;
    Defines the Abstract process of processing tasks for a certain process.
    &#34;&#34;&#34;

    def __init__(
        self, execute_serial: bool = False, chunksize: int = 3, paralleltasks: int = 3, max_tasks_per_second: int = 8
    ):
        self.execute_serial = execute_serial
        self.chunksize = chunksize
        self.paralleltasks = paralleltasks
        self.max_tasks_per_second = max_tasks_per_second

        # since failed tasks are retried, results[FAILED] can contain multiple entries for
        # a tasks that is retried multiple times.
        self.results: Dict[TaskResultState, List[TaskResult]] = defaultdict(list)

        self.failed_tasks: List[Task] = []

    @abstractmethod
    def calculate_tasks(self) -&gt; List[Task]:
        &#34;&#34;&#34;
        Calculate the tasks that have to be executed for the implemented process

        Returns:
            List[Tasks] : List of the tasks to be processed.
        &#34;&#34;&#34;

    def pre_process(self):
        &#34;&#34;&#34;Hook method to implement logic that is executed before the whole process is finished.&#34;&#34;&#34;

    def post_process(self):
        &#34;&#34;&#34;Hook method to implement logic that is executed after the whole process is finished.&#34;&#34;&#34;

    @staticmethod
    def process_task(task: Task) -&gt; TaskResult:
        &#34;&#34;&#34;
        execute a single task.
        &#34;&#34;&#34;
        logger = logging.getLogger()
        try:
            task.prepare()
            task.execute()
            result = TaskResult(task=task, result=task.commit(), state=TaskResultState.SUCCESS)
            logger.info(&#34;Success: %s&#34;, task)
            return result
        except Exception as ex:  # pylint: disable=W0703
            # we want to catch everything here.
            logger.info(&#34;Failed: %s / %s &#34;, task, ex)
            return TaskResult(task=task, result=task.exception(exception=ex), state=TaskResultState.FAILED)

    def process(self):
        &#34;&#34;&#34;
        execute the process by executing all the tasks that need to be executed.
        The execution can happen in parallel or serial.

        There is a retry mechanism for failing tasks.

        &#34;&#34;&#34;
        logger = logging.getLogger()
        logger.info(&#34;Starting process %s&#34;, self.__class__.__name__)

        self.pre_process()

        results_all, failed_tasks = self.do_execution()
        self.failed_tasks = failed_tasks

        for entry in results_all:
            self.results[entry.state].append(entry)

        for failed in self.failed_tasks:
            logger.warning(&#34;not able to process %s&#34;, failed)

        self.post_process()

    @abstractmethod
    def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
        &#34;&#34;&#34;
        handle to real execution.
        &#34;&#34;&#34;


class AbstractThreadProcess(AbstractParallelProcess):
    &#34;&#34;&#34;
    Uses for the parallel execution logic a Thread-Based approach.
    &#34;&#34;&#34;

    def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
        &#34;&#34;&#34;
        Using a thread-based executor.
        &#34;&#34;&#34;
        executor = ThreadExecutor[Task, TaskResult, TaskResult](
            processes=self.paralleltasks,
            max_calls_per_sec=self.max_tasks_per_second,
            chunksize=self.chunksize,
            execute_serial=self.execute_serial,
        )
        executor.set_get_entries_function(self.calculate_tasks)
        executor.set_process_element_function(self.process_task)
        executor.set_post_process_chunk_function(lambda x: x)  # no process_chunk for this purpose
        return executor.execute()


class AbstractProcessPoolProcess(AbstractParallelProcess):
    &#34;&#34;&#34;
    Uses for the parallel execution logic a Thread-Based approach.
    &#34;&#34;&#34;

    def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
        &#34;&#34;&#34;
        Using a process-based executor.
        &#34;&#34;&#34;
        executor = ParallelExecutor[Task, TaskResult, TaskResult](
            processes=self.paralleltasks,
            max_calls_per_sec=self.max_tasks_per_second,
            chunksize=self.chunksize,
            execute_serial=self.execute_serial,
        )
        executor.set_get_entries_function(self.calculate_tasks)
        executor.set_process_element_function(self.process_task)
        executor.set_post_process_chunk_function(lambda x: x)  # no process_chunk for this purpose
        return executor.execute()


def execute_processes(processes: List[AbstractProcess]):
    &#34;&#34;&#34;
        Execute the list of processes in serial
    Args:
        processes (List(AbstractProcess)): List of AbstractProcesses to be executed

    &#34;&#34;&#34;
    for process in processes:
        process.process()


class LoggingProcess(AbstractProcess):
    &#34;&#34;&#34;
    Simple process that just logs some information.
    &#34;&#34;&#34;

    def __init__(self, title: str, lines: List[str]):
        &#34;&#34;&#34;
        Constructor.
        Args:
            title: title of the process
            lines: list of lines to be logged
        &#34;&#34;&#34;
        super().__init__()
        self.title = title
        self.lines = lines

    def process(self):
        &#34;&#34;&#34;execute the process.&#34;&#34;&#34;
        logger = logging.getLogger()

        length_title = len(self.title)

        logger.info(&#34;&#34;)
        logger.info(&#34;#&#34; * (length_title + 4))
        logger.info(&#34;%s&#34;, self.title)

        for line in self.lines:
            logger.info(&#34;    %s&#34;, line)

        logger.info(&#34;#&#34; * (length_title + 4))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="secfsdstools.c_automation.task_framework.execute_processes"><code class="name flex">
<span>def <span class="ident">execute_processes</span></span>(<span>processes:Â List[<a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the list of processes in serial</p>
<h2 id="args">Args</h2>
<p>processes (List(AbstractProcess)): List of AbstractProcesses to be executed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_processes(processes: List[AbstractProcess]):
    &#34;&#34;&#34;
        Execute the list of processes in serial
    Args:
        processes (List(AbstractProcess)): List of AbstractProcesses to be executed

    &#34;&#34;&#34;
    for process in processes:
        process.process()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess"><code class="flex name class">
<span>class <span class="ident">AbstractParallelProcess</span></span>
<span>(</span><span>execute_serial:Â boolÂ =Â False, chunksize:Â intÂ =Â 3, paralleltasks:Â intÂ =Â 3, max_tasks_per_second:Â intÂ =Â 8)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the Abstract process of processing tasks for a certain process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractParallelProcess(AbstractProcess):
    &#34;&#34;&#34;
    Defines the Abstract process of processing tasks for a certain process.
    &#34;&#34;&#34;

    def __init__(
        self, execute_serial: bool = False, chunksize: int = 3, paralleltasks: int = 3, max_tasks_per_second: int = 8
    ):
        self.execute_serial = execute_serial
        self.chunksize = chunksize
        self.paralleltasks = paralleltasks
        self.max_tasks_per_second = max_tasks_per_second

        # since failed tasks are retried, results[FAILED] can contain multiple entries for
        # a tasks that is retried multiple times.
        self.results: Dict[TaskResultState, List[TaskResult]] = defaultdict(list)

        self.failed_tasks: List[Task] = []

    @abstractmethod
    def calculate_tasks(self) -&gt; List[Task]:
        &#34;&#34;&#34;
        Calculate the tasks that have to be executed for the implemented process

        Returns:
            List[Tasks] : List of the tasks to be processed.
        &#34;&#34;&#34;

    def pre_process(self):
        &#34;&#34;&#34;Hook method to implement logic that is executed before the whole process is finished.&#34;&#34;&#34;

    def post_process(self):
        &#34;&#34;&#34;Hook method to implement logic that is executed after the whole process is finished.&#34;&#34;&#34;

    @staticmethod
    def process_task(task: Task) -&gt; TaskResult:
        &#34;&#34;&#34;
        execute a single task.
        &#34;&#34;&#34;
        logger = logging.getLogger()
        try:
            task.prepare()
            task.execute()
            result = TaskResult(task=task, result=task.commit(), state=TaskResultState.SUCCESS)
            logger.info(&#34;Success: %s&#34;, task)
            return result
        except Exception as ex:  # pylint: disable=W0703
            # we want to catch everything here.
            logger.info(&#34;Failed: %s / %s &#34;, task, ex)
            return TaskResult(task=task, result=task.exception(exception=ex), state=TaskResultState.FAILED)

    def process(self):
        &#34;&#34;&#34;
        execute the process by executing all the tasks that need to be executed.
        The execution can happen in parallel or serial.

        There is a retry mechanism for failing tasks.

        &#34;&#34;&#34;
        logger = logging.getLogger()
        logger.info(&#34;Starting process %s&#34;, self.__class__.__name__)

        self.pre_process()

        results_all, failed_tasks = self.do_execution()
        self.failed_tasks = failed_tasks

        for entry in results_all:
            self.results[entry.state].append(entry)

        for failed in self.failed_tasks:
            logger.warning(&#34;not able to process %s&#34;, failed)

        self.post_process()

    @abstractmethod
    def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
        &#34;&#34;&#34;
        handle to real execution.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess">AbstractProcessPoolProcess</a></li>
<li><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess" href="#secfsdstools.c_automation.task_framework.AbstractThreadProcess">AbstractThreadProcess</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task"><code class="name flex">
<span>def <span class="ident">process_task</span></span>(<span>task:Â <a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a>) â€‘>Â <a title="secfsdstools.c_automation.task_framework.TaskResult" href="#secfsdstools.c_automation.task_framework.TaskResult">TaskResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>execute a single task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process_task(task: Task) -&gt; TaskResult:
    &#34;&#34;&#34;
    execute a single task.
    &#34;&#34;&#34;
    logger = logging.getLogger()
    try:
        task.prepare()
        task.execute()
        result = TaskResult(task=task, result=task.commit(), state=TaskResultState.SUCCESS)
        logger.info(&#34;Success: %s&#34;, task)
        return result
    except Exception as ex:  # pylint: disable=W0703
        # we want to catch everything here.
        logger.info(&#34;Failed: %s / %s &#34;, task, ex)
        return TaskResult(task=task, result=task.exception(exception=ex), state=TaskResultState.FAILED)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks"><code class="name flex">
<span>def <span class="ident">calculate_tasks</span></span>(<span>self) â€‘>Â List[<a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the tasks that have to be executed for the implemented process</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Tasks] </code></dt>
<dd>List of the tasks to be processed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def calculate_tasks(self) -&gt; List[Task]:
    &#34;&#34;&#34;
    Calculate the tasks that have to be executed for the implemented process

    Returns:
        List[Tasks] : List of the tasks to be processed.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess.do_execution"><code class="name flex">
<span>def <span class="ident">do_execution</span></span>(<span>self) â€‘>Â Tuple[List[<a title="secfsdstools.c_automation.task_framework.TaskResult" href="#secfsdstools.c_automation.task_framework.TaskResult">TaskResult</a>],Â List[<a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>handle to real execution.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
    &#34;&#34;&#34;
    handle to real execution.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process"><code class="name flex">
<span>def <span class="ident">post_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method to implement logic that is executed after the whole process is finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_process(self):
    &#34;&#34;&#34;Hook method to implement logic that is executed after the whole process is finished.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process"><code class="name flex">
<span>def <span class="ident">pre_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Hook method to implement logic that is executed before the whole process is finished.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_process(self):
    &#34;&#34;&#34;Hook method to implement logic that is executed before the whole process is finished.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>execute the process by executing all the tasks that need to be executed.
The execution can happen in parallel or serial.</p>
<p>There is a retry mechanism for failing tasks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    &#34;&#34;&#34;
    execute the process by executing all the tasks that need to be executed.
    The execution can happen in parallel or serial.

    There is a retry mechanism for failing tasks.

    &#34;&#34;&#34;
    logger = logging.getLogger()
    logger.info(&#34;Starting process %s&#34;, self.__class__.__name__)

    self.pre_process()

    results_all, failed_tasks = self.do_execution()
    self.failed_tasks = failed_tasks

    for entry in results_all:
        self.results[entry.state].append(entry)

    for failed in self.failed_tasks:
        logger.warning(&#34;not able to process %s&#34;, failed)

    self.post_process()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractProcess"><code class="flex name class">
<span>class <span class="ident">AbstractProcess</span></span>
</code></dt>
<dd>
<div class="desc"><p>Defines the Abstract process of processing tasks for a certain process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractProcess(ABC):
    &#34;&#34;&#34;
    Defines the Abstract process of processing tasks for a certain process.
    &#34;&#34;&#34;

    @abstractmethod
    def process(self):
        &#34;&#34;&#34;executes the process.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></li>
<li><a title="secfsdstools.c_automation.task_framework.LoggingProcess" href="#secfsdstools.c_automation.task_framework.LoggingProcess">LoggingProcess</a></li>
<li><a title="secfsdstools.c_daily.dailypreparation_process.DailyPreparationProcess" href="../c_daily/dailypreparation_process.html#secfsdstools.c_daily.dailypreparation_process.DailyPreparationProcess">DailyPreparationProcess</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractProcess.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>executes the process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def process(self):
    &#34;&#34;&#34;executes the process.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess"><code class="flex name class">
<span>class <span class="ident">AbstractProcessPoolProcess</span></span>
<span>(</span><span>execute_serial:Â boolÂ =Â False, chunksize:Â intÂ =Â 3, paralleltasks:Â intÂ =Â 3, max_tasks_per_second:Â intÂ =Â 8)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses for the parallel execution logic a Thread-Based approach.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractProcessPoolProcess(AbstractParallelProcess):
    &#34;&#34;&#34;
    Uses for the parallel execution logic a Thread-Based approach.
    &#34;&#34;&#34;

    def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
        &#34;&#34;&#34;
        Using a process-based executor.
        &#34;&#34;&#34;
        executor = ParallelExecutor[Task, TaskResult, TaskResult](
            processes=self.paralleltasks,
            max_calls_per_sec=self.max_tasks_per_second,
            chunksize=self.chunksize,
            execute_serial=self.execute_serial,
        )
        executor.set_get_entries_function(self.calculate_tasks)
        executor.set_process_element_function(self.process_task)
        executor.set_post_process_chunk_function(lambda x: x)  # no process_chunk for this purpose
        return executor.execute()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></li>
<li><a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_transform.toparquettransforming_process.ToParquetTransformerProcess" href="../c_transform/toparquettransforming_process.html#secfsdstools.c_transform.toparquettransforming_process.ToParquetTransformerProcess">ToParquetTransformerProcess</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess.do_execution"><code class="name flex">
<span>def <span class="ident">do_execution</span></span>(<span>self) â€‘>Â Tuple[List[<a title="secfsdstools.c_automation.task_framework.TaskResult" href="#secfsdstools.c_automation.task_framework.TaskResult">TaskResult</a>],Â List[<a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Using a process-based executor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
    &#34;&#34;&#34;
    Using a process-based executor.
    &#34;&#34;&#34;
    executor = ParallelExecutor[Task, TaskResult, TaskResult](
        processes=self.paralleltasks,
        max_calls_per_sec=self.max_tasks_per_second,
        chunksize=self.chunksize,
        execute_serial=self.execute_serial,
    )
    executor.set_get_entries_function(self.calculate_tasks)
    executor.set_process_element_function(self.process_task)
    executor.set_post_process_chunk_function(lambda x: x)  # no process_chunk for this purpose
    return executor.execute()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks">calculate_tasks</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process">post_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process">pre_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process">process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task">process_task</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask"><code class="flex name class">
<span>class <span class="ident">AbstractTask</span></span>
<span>(</span><span>root_paths:Â List[pathlib.Path], pathfilter:Â str, target_path:Â pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract Base implemenation providing some commonly used basic functionality.</p>
<p>It is based on reading subfolders from a root_path, which are defined by pathfilter.
Then processing the content of these folders and writing the result in a target_path.</p>
<p>The result is created in tmp-folder and is then "commited" by renaming the tmp-folder into
the target-path, therefore providing an atomic-action (renaming) that acts as commit.</p>
<p>It also provides basic implementation of "meta.inf" file, that can be stored in the target.
The idea of the meta.inf file is, to give a hint of what already was processed from the
root_path in a previous, step.</p>
<p>For example, the meta.inf could contain a list of subfolder names that were already processed.
Therefore, if a new subfolder appears in the root_path, the task would knwow which subfolders
need to be process. another possibility is to store the timestamp of the data, which was
processed (in cases, where the content of files within the subfolders in root_path changes, but
not the subfolders themselves). Therefore, allowing to check whether a modification timestamp
of files in the root_path is newer than the timestamp stored in the meta.inf file.</p>
<p>The constructor of the AbstracTask.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_paths</code></strong></dt>
<dd>list of root_paths of the data to be processed</dd>
<dt><strong><code>pathfilter</code></strong></dt>
<dd>a pathfilter string (e.g. "<em>"; as defined for Path.glob()) to select the
subfolders in the root_paths, that have to be processed.
pathfilter could be something like "</em>", or "<em>/BS", or "something/</em>/BS".<pre><code>E.g., the following root_path structure and the pathfilter "*/BS"
would select all "BS" "sub-subfolders" within root_path:
&lt;pre&gt;
   &lt;root_path&gt;
        2010a1.zip/BS
        2010q1.zip/IS
        2010q1.zip/CF
        ...
        2024a4.zip/BS
        2024q4.zip/IS
        2024q4.zip/CF
&lt;/pre&gt;
</code></pre>
</dd>
<dt><strong><code>target_path</code></strong></dt>
<dd>the target_path to write the results to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractTask:
    &#34;&#34;&#34;
    Abstract Base implemenation providing some commonly used basic functionality.

    It is based on reading subfolders from a root_path, which are defined by pathfilter.
    Then processing the content of these folders and writing the result in a target_path.

    The result is created in tmp-folder and is then &#34;commited&#34; by renaming the tmp-folder into
    the target-path, therefore providing an atomic-action (renaming) that acts as commit.

    It also provides basic implementation of &#34;meta.inf&#34; file, that can be stored in the target.
    The idea of the meta.inf file is, to give a hint of what already was processed from the
    root_path in a previous, step.

    For example, the meta.inf could contain a list of subfolder names that were already processed.
    Therefore, if a new subfolder appears in the root_path, the task would knwow which subfolders
    need to be process. another possibility is to store the timestamp of the data, which was
    processed (in cases, where the content of files within the subfolders in root_path changes, but
    not the subfolders themselves). Therefore, allowing to check whether a modification timestamp
    of files in the root_path is newer than the timestamp stored in the meta.inf file.

    &#34;&#34;&#34;

    def __init__(self, root_paths: List[Path], pathfilter: str, target_path: Path):
        &#34;&#34;&#34;
        The constructor of the AbstracTask.

        Args:
            root_paths: list of root_paths of the data to be processed
            pathfilter: a pathfilter string (e.g. &#34;*&#34;; as defined for Path.glob()) to select the
                    subfolders in the root_paths, that have to be processed.
                    pathfilter could be something like &#34;*&#34;, or &#34;*/BS&#34;, or &#34;something/*/BS&#34;.

                    E.g., the following root_path structure and the pathfilter &#34;*/BS&#34;
                    would select all &#34;BS&#34; &#34;sub-subfolders&#34; within root_path:
                    &lt;pre&gt;
                       &lt;root_path&gt;
                            2010a1.zip/BS
                            2010q1.zip/IS
                            2010q1.zip/CF
                            ...
                            2024a4.zip/BS
                            2024q4.zip/IS
                            2024q4.zip/CF
                    &lt;/pre&gt;

            target_path: the target_path to write the results to.
        &#34;&#34;&#34;

        self.root_paths = root_paths
        self.target_path = target_path
        self.filter = pathfilter

        self.filtered_paths: List[Path] = []

        if self.filter is None or self.filter == &#34;&#34;:
            self.filtered_paths.extend(self.root_paths)
        else:
            for root_path in root_paths:
                self.filtered_paths.extend(list(root_path.glob(self.filter)))

        # usually, all filtered_paths have to be processed
        self.paths_to_process: List[Path] = self.filtered_paths

        # define the tmp_path
        self.tmp_path = target_path.parent / f&#34;tmp_{target_path.name}&#34;
        self.meta_inf_file: Path = self.target_path / &#34;meta.inf&#34;

        # pathfilter could be something like &#34;*&#34;, or &#34;*/BS&#34;, or &#34;something/*/BS&#34;
        # but in order to be able to fill the metainf file with the names for which &#34;*&#34; iterates
        # over, we need to know the position of the &#34;*&#34; from the end of the resulting path.
        # So if the pathfilter is just a &#34;*&#34; it is 0, if it is &#34;*/BS&#34; it would be 1
        self.star_position = self._star_position_from_end(self.filter)

    @staticmethod
    def _star_position_from_end(path: str) -&gt; int:
        &#34;&#34;&#34;
        Gets the position of the &#34;*&#34; in the provided path (counted from the end).

        Examples:
            path = &#34;a/b/c/d/*&#34; -&gt; returns 0
            path = &#34;a/b/c/*/d&#34; -&gt; returns 1
            path = &#34;a/b/*/c/d&#34; -&gt; returns 2

        Args:
            path: path with a &#34;*&#34; as part

        Returns:
            the position of the &#34;*&#34; in the path, counted from the end.
        &#34;&#34;&#34;

        # ignore first and last /
        if path.startswith(&#34;/&#34;):
            path = path[1:]
        if path.endswith(&#34;/&#34;):
            path = path[:-1]

        # Split the string by &#39;/&#39; to get segments
        segments = path.split(&#34;/&#34;)

        # Iterate from the end and find the first segment containing &#39;*&#39;
        for i, segment in enumerate(reversed(segments)):
            if &#34;*&#34; in segment:
                return i  # Position from the end

        # If no &#39;*&#39; is found, return -1 to indicate an error
        return -1

    @staticmethod
    def _get_star_position_name(path: Path, star_position: int) -&gt; str:
        &#34;&#34;&#34;
        Gets the name of the part where the &#34;*&#34; is positioned in the pathfilter-string.

        Example:
             path = &#34;a/b/c&#34; and star_position = 0 -&gt; returns c
             path = &#34;a/b/c&#34; and star_position = 1 -&gt; returns b
             path = &#34;a/b/c&#34; and star_position = 2 -&gt; returns c

        Args:
            path: path from which the name_part at the star_position has to be returned
            star_position: position of the part which name has to be returned.

        Returns:
            str: name of the part defined by the star_position

        &#34;&#34;&#34;
        # reverse list with [::-1]
        return path.parts[::-1][star_position]

    def read_metainf_content(self) -&gt; List[str]:
        &#34;&#34;&#34;
        reads the content from the meta.inf file in an existing target_path
        Returns:
            List(str): the content by line
        &#34;&#34;&#34;
        meta_inf_content = self.meta_inf_file.read_text(encoding=&#34;utf-8&#34;)
        return meta_inf_content.split(&#34;\n&#34;)

    def exception(self, exception) -&gt; str:
        &#34;&#34;&#34;
        Basic implementation of the exception method.
        It deletes the temp folder and returns a &#34;failed&#34; message.
        &#34;&#34;&#34;
        shutil.rmtree(self.tmp_path, ignore_errors=True)
        return f&#34;failed {exception}&#34;

    def has_work_todo(self) -&gt; bool:
        &#34;&#34;&#34;
        returns true if there is actual work to do, otherwise False.
        Can be overwritten.
        Default implementation just looks if the provided root_path has subfolders, that are
        defined by the provided pathfilter string.
        &#34;&#34;&#34;
        return len(self.paths_to_process) &gt; 0

    def prepare(self):
        &#34;&#34;&#34;
        basic implementation of the prepare method. Does nothing if there is nothing to process
        or does create the tmp_folder, if processing has to be done.
        &#34;&#34;&#34;
        if not self.has_work_todo():
            return

        self.tmp_path.mkdir(parents=True, exist_ok=False)

    def commit(self):
        &#34;&#34;&#34;
        Basic implementation of the commit method.
        If nothing had to be done, it simply returns &#34;success&#34;.
        If work was done, it removes an existing target_path, and overwrites it with the
        content of the tmp_path (by renaming the tmp_path to the target_path, which is an
        atomic action, which either fails, or succeeds).
        &#34;&#34;&#34;
        if not self.has_work_todo():
            return &#34;success&#34;

        # Remove old content of target_path
        if self.target_path.exists():
            shutil.rmtree(self.target_path)

        # rename the tmp_path, so this is like an atomic action that either fails or succeeds.
        self.tmp_path.rename(self.target_path)
        return &#34;success&#34;

    def write_meta_inf(self, content: str):
        &#34;&#34;&#34;
        writes the provided content into the the meta_inf file in the tmp-path.
        Args:
            content: content to be written
        &#34;&#34;&#34;
        temp_meta_inf = self.tmp_path / &#34;meta.inf&#34;
        temp_meta_inf.write_text(data=content, encoding=&#34;utf-8&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask" href="#secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask">CheckByNewSubfoldersMergeBaseTask</a></li>
<li><a title="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask" href="#secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask">CheckByTimestampMergeBaseTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic implementation of the commit method.
If nothing had to be done, it simply returns "success".
If work was done, it removes an existing target_path, and overwrites it with the
content of the tmp_path (by renaming the tmp_path to the target_path, which is an
atomic action, which either fails, or succeeds).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self):
    &#34;&#34;&#34;
    Basic implementation of the commit method.
    If nothing had to be done, it simply returns &#34;success&#34;.
    If work was done, it removes an existing target_path, and overwrites it with the
    content of the tmp_path (by renaming the tmp_path to the target_path, which is an
    atomic action, which either fails, or succeeds).
    &#34;&#34;&#34;
    if not self.has_work_todo():
        return &#34;success&#34;

    # Remove old content of target_path
    if self.target_path.exists():
        shutil.rmtree(self.target_path)

    # rename the tmp_path, so this is like an atomic action that either fails or succeeds.
    self.tmp_path.rename(self.target_path)
    return &#34;success&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask.exception"><code class="name flex">
<span>def <span class="ident">exception</span></span>(<span>self, exception) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Basic implementation of the exception method.
It deletes the temp folder and returns a "failed" message.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exception(self, exception) -&gt; str:
    &#34;&#34;&#34;
    Basic implementation of the exception method.
    It deletes the temp folder and returns a &#34;failed&#34; message.
    &#34;&#34;&#34;
    shutil.rmtree(self.tmp_path, ignore_errors=True)
    return f&#34;failed {exception}&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo"><code class="name flex">
<span>def <span class="ident">has_work_todo</span></span>(<span>self) â€‘>Â bool</span>
</code></dt>
<dd>
<div class="desc"><p>returns true if there is actual work to do, otherwise False.
Can be overwritten.
Default implementation just looks if the provided root_path has subfolders, that are
defined by the provided pathfilter string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def has_work_todo(self) -&gt; bool:
    &#34;&#34;&#34;
    returns true if there is actual work to do, otherwise False.
    Can be overwritten.
    Default implementation just looks if the provided root_path has subfolders, that are
    defined by the provided pathfilter string.
    &#34;&#34;&#34;
    return len(self.paths_to_process) &gt; 0</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>basic implementation of the prepare method. Does nothing if there is nothing to process
or does create the tmp_folder, if processing has to be done.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34;
    basic implementation of the prepare method. Does nothing if there is nothing to process
    or does create the tmp_folder, if processing has to be done.
    &#34;&#34;&#34;
    if not self.has_work_todo():
        return

    self.tmp_path.mkdir(parents=True, exist_ok=False)</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content"><code class="name flex">
<span>def <span class="ident">read_metainf_content</span></span>(<span>self) â€‘>Â List[str]</span>
</code></dt>
<dd>
<div class="desc"><p>reads the content from the meta.inf file in an existing target_path</p>
<h2 id="returns">Returns</h2>
<p>List(str): the content by line</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_metainf_content(self) -&gt; List[str]:
    &#34;&#34;&#34;
    reads the content from the meta.inf file in an existing target_path
    Returns:
        List(str): the content by line
    &#34;&#34;&#34;
    meta_inf_content = self.meta_inf_file.read_text(encoding=&#34;utf-8&#34;)
    return meta_inf_content.split(&#34;\n&#34;)</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf"><code class="name flex">
<span>def <span class="ident">write_meta_inf</span></span>(<span>self, content:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>writes the provided content into the the meta_inf file in the tmp-path.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>content</code></strong></dt>
<dd>content to be written</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_meta_inf(self, content: str):
    &#34;&#34;&#34;
    writes the provided content into the the meta_inf file in the tmp-path.
    Args:
        content: content to be written
    &#34;&#34;&#34;
    temp_meta_inf = self.tmp_path / &#34;meta.inf&#34;
    temp_meta_inf.write_text(data=content, encoding=&#34;utf-8&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.c_automation.task_framework.AbstractThreadProcess"><code class="flex name class">
<span>class <span class="ident">AbstractThreadProcess</span></span>
<span>(</span><span>execute_serial:Â boolÂ =Â False, chunksize:Â intÂ =Â 3, paralleltasks:Â intÂ =Â 3, max_tasks_per_second:Â intÂ =Â 8)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses for the parallel execution logic a Thread-Based approach.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractThreadProcess(AbstractParallelProcess):
    &#34;&#34;&#34;
    Uses for the parallel execution logic a Thread-Based approach.
    &#34;&#34;&#34;

    def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
        &#34;&#34;&#34;
        Using a thread-based executor.
        &#34;&#34;&#34;
        executor = ThreadExecutor[Task, TaskResult, TaskResult](
            processes=self.paralleltasks,
            max_calls_per_sec=self.max_tasks_per_second,
            chunksize=self.chunksize,
            execute_serial=self.execute_serial,
        )
        executor.set_get_entries_function(self.calculate_tasks)
        executor.set_process_element_function(self.process_task)
        executor.set_post_process_chunk_function(lambda x: x)  # no process_chunk for this purpose
        return executor.execute()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></li>
<li><a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_download.basedownloading_process.BaseDownloadingProcess" href="../c_download/basedownloading_process.html#secfsdstools.c_download.basedownloading_process.BaseDownloadingProcess">BaseDownloadingProcess</a></li>
<li><a title="secfsdstools.c_index.indexing_process.ReportParquetIndexerProcess" href="../c_index/indexing_process.html#secfsdstools.c_index.indexing_process.ReportParquetIndexerProcess">ReportParquetIndexerProcess</a></li>
<li><a title="secfsdstools.g_pipelines.concat_process.ConcatByNewSubfoldersProcess" href="../g_pipelines/concat_process.html#secfsdstools.g_pipelines.concat_process.ConcatByNewSubfoldersProcess">ConcatByNewSubfoldersProcess</a></li>
<li><a title="secfsdstools.g_pipelines.concat_process.ConcatMultiRootByChangedTimestampProcess" href="../g_pipelines/concat_process.html#secfsdstools.g_pipelines.concat_process.ConcatMultiRootByChangedTimestampProcess">ConcatMultiRootByChangedTimestampProcess</a></li>
<li><a title="secfsdstools.g_pipelines.filter_process.FilterProcess" href="../g_pipelines/filter_process.html#secfsdstools.g_pipelines.filter_process.FilterProcess">FilterProcess</a></li>
<li><a title="secfsdstools.g_pipelines.standardize_process.StandardizeProcess" href="../g_pipelines/standardize_process.html#secfsdstools.g_pipelines.standardize_process.StandardizeProcess">StandardizeProcess</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.AbstractThreadProcess.do_execution"><code class="name flex">
<span>def <span class="ident">do_execution</span></span>(<span>self) â€‘>Â Tuple[List[<a title="secfsdstools.c_automation.task_framework.TaskResult" href="#secfsdstools.c_automation.task_framework.TaskResult">TaskResult</a>],Â List[<a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Using a thread-based executor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do_execution(self) -&gt; Tuple[List[TaskResult], List[Task]]:
    &#34;&#34;&#34;
    Using a thread-based executor.
    &#34;&#34;&#34;
    executor = ThreadExecutor[Task, TaskResult, TaskResult](
        processes=self.paralleltasks,
        max_calls_per_sec=self.max_tasks_per_second,
        chunksize=self.chunksize,
        execute_serial=self.execute_serial,
    )
    executor.set_get_entries_function(self.calculate_tasks)
    executor.set_process_element_function(self.process_task)
    executor.set_post_process_chunk_function(lambda x: x)  # no process_chunk for this purpose
    return executor.execute()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks">calculate_tasks</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process">post_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process">pre_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process">process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task">process_task</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask"><code class="flex name class">
<span>class <span class="ident">CheckByNewSubfoldersMergeBaseTask</span></span>
<span>(</span><span>root_paths:Â List[pathlib.Path], pathfilter:Â str, target_path:Â pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Implements the basic logic to track already processed data either by folder structure of the
root-path (meaning that new data that appeared as a new subfolder in the root-path has to be
integrated in the existing content of the target path) or by
checking the timestamp of the latest modifications within the root-path structure (meaning
that the content of the target-path has to be recreated with the current content of the
root-path.</p>
<p>Both scenarios use a "meta-inf" file that either contains the name of the subfolders, or the
the timestamp of the latest processed modification.</p>
<p>Constructor of base task.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root_paths</code></strong></dt>
<dd>root paths to read data from</dd>
<dt><strong><code>pathfilter</code></strong></dt>
<dd>pathfilter string that defines which subfolders in the
root_path have to be selected</dd>
<dt><strong><code>target_path</code></strong></dt>
<dd>path to where the results have to be written</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckByNewSubfoldersMergeBaseTask(AbstractTask):
    &#34;&#34;&#34;
    Implements the basic logic to track already processed data either by folder structure of the
    root-path (meaning that new data that appeared as a new subfolder in the root-path has to be
    integrated in the existing content of the target path) or by
    checking the timestamp of the latest modifications within the root-path structure (meaning
    that the content of the target-path has to be recreated with the current content of the
    root-path.

    Both scenarios use a &#34;meta-inf&#34; file that either contains the name of the subfolders, or the
    the timestamp of the latest processed modification.
    &#34;&#34;&#34;

    def __init__(self, root_paths: List[Path], pathfilter: str, target_path: Path):
        &#34;&#34;&#34;
        Constructor of base task.

        Args:
            root_paths: root paths to read data from
            pathfilter: pathfilter string that defines which subfolders in the
                        root_path have to be selected
            target_path: path to where the results have to be written
        &#34;&#34;&#34;
        self.all_names: Dict[str, Path]

        super().__init__(
            root_paths=root_paths,
            pathfilter=pathfilter,
            target_path=target_path,
        )

        # so if we have the pathfilter */BS and if we have the directories &#34;2010q1.zip/BS&#34;,
        # &#34;2010q2.zip/BS&#34; in the root_path, all_names key will be 2010q1.zip, 2010q2.zip
        self.all_names = {
            self._get_star_position_name(path=p, star_position=self.star_position): p for p in self.paths_to_process
        }

        if self.meta_inf_file.exists():
            containing_values = self.read_metainf_content()

            missing = set(self.all_names.keys()) - set(containing_values)
            self.paths_to_process = [self.all_names[name] for name in missing]

    def execute(self):
        &#34;&#34;&#34;
        Basic implementation of the execute method.

        If there are &#34;paths_to_process&#34;, what has to be done depending on &#34;check_by_timestamp&#34;
        being true or not.


        Returns:

        &#34;&#34;&#34;
        if len(self.paths_to_process) == 0:
            return

        paths_to_process = self.paths_to_process.copy()

        # depending on the use case, we need to combine new data with already
        # existing data in the target.
        # therefore, we provide a list &#34;paths_to_process&#34; which contains subfolders that are new,
        # the processed_path (the path that contains the result of the last processing), and
        # the target_path, where we have to store the result to (this the tmp folder)
        self.do_execution(paths_to_process=paths_to_process, target_path=self.target_path, tmp_path=self.tmp_path)

        meta_inf_content: str = &#34;\n&#34;.join(
            [self._get_star_position_name(f, self.star_position) for f in self.filtered_paths]
        )
        self.write_meta_inf(content=meta_inf_content)

    @abstractmethod
    def do_execution(self, paths_to_process: List[Path], target_path: Path, tmp_path: Path):
        &#34;&#34;&#34;
            defines the logic to be executed.
        Args:
            paths_to_process: lists of paths/folders that have to be processed
            target_path: the path where the result of the previous run was written
            tmp_path: target path to where a result has to be written
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractTask" href="#secfsdstools.c_automation.task_framework.AbstractTask">AbstractTask</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.g_pipelines.concat_process.ConcatIfNewSubfolderTask" href="../g_pipelines/concat_process.html#secfsdstools.g_pipelines.concat_process.ConcatIfNewSubfolderTask">ConcatIfNewSubfolderTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask.do_execution"><code class="name flex">
<span>def <span class="ident">do_execution</span></span>(<span>self, paths_to_process:Â List[pathlib.Path], target_path:Â pathlib.Path, tmp_path:Â pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>defines the logic to be executed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths_to_process</code></strong></dt>
<dd>lists of paths/folders that have to be processed</dd>
<dt><strong><code>target_path</code></strong></dt>
<dd>the path where the result of the previous run was written</dd>
<dt><strong><code>tmp_path</code></strong></dt>
<dd>target path to where a result has to be written</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def do_execution(self, paths_to_process: List[Path], target_path: Path, tmp_path: Path):
    &#34;&#34;&#34;
        defines the logic to be executed.
    Args:
        paths_to_process: lists of paths/folders that have to be processed
        target_path: the path where the result of the previous run was written
        tmp_path: target path to where a result has to be written
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic implementation of the execute method.</p>
<p>If there are "paths_to_process", what has to be done depending on "check_by_timestamp"
being true or not.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#34;&#34;&#34;
    Basic implementation of the execute method.

    If there are &#34;paths_to_process&#34;, what has to be done depending on &#34;check_by_timestamp&#34;
    being true or not.


    Returns:

    &#34;&#34;&#34;
    if len(self.paths_to_process) == 0:
        return

    paths_to_process = self.paths_to_process.copy()

    # depending on the use case, we need to combine new data with already
    # existing data in the target.
    # therefore, we provide a list &#34;paths_to_process&#34; which contains subfolders that are new,
    # the processed_path (the path that contains the result of the last processing), and
    # the target_path, where we have to store the result to (this the tmp folder)
    self.do_execution(paths_to_process=paths_to_process, target_path=self.target_path, tmp_path=self.tmp_path)

    meta_inf_content: str = &#34;\n&#34;.join(
        [self._get_star_position_name(f, self.star_position) for f in self.filtered_paths]
    )
    self.write_meta_inf(content=meta_inf_content)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.c_automation.task_framework.AbstractTask" href="#secfsdstools.c_automation.task_framework.AbstractTask">AbstractTask</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.commit" href="#secfsdstools.c_automation.task_framework.AbstractTask.commit">commit</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.exception" href="#secfsdstools.c_automation.task_framework.AbstractTask.exception">exception</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo" href="#secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo">has_work_todo</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.prepare" href="#secfsdstools.c_automation.task_framework.AbstractTask.prepare">prepare</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content" href="#secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content">read_metainf_content</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf" href="#secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf">write_meta_inf</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask"><code class="flex name class">
<span>class <span class="ident">CheckByTimestampMergeBaseTask</span></span>
<span>(</span><span>root_paths:Â List[pathlib.Path], pathfilter:Â str, target_path:Â pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>This class uses the AbstractTask to implement logic that checks if files were changed within
the root_path since the last processing.</p>
<p>It can be used as a BaseClass to implement a Task, that checks for new data to be processed
by looking at the modification timestamp of the files in the root_path.</p>
<p>It does this as follows:
- if there is no target_path yet, it will process the content in the root_path,
write the result in the target_path together with a meta.inf file that contains
the newest modification timestamp of all the files in the root_path.
- if there is a target_path, then it reads the timestamp, that is stored within the target_path.
It any of the files within the root_path has a newer modification timestamp, it will
process the data and also update the timestamp in the meta.inf file</p>
<p>The constructor of the CheckByTimestampMergeBaseTask.
Check also the documentation of the AbstractTask Constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CheckByTimestampMergeBaseTask(AbstractTask):
    &#34;&#34;&#34;
    This class uses the AbstractTask to implement logic that checks if files were changed within
    the root_path since the last processing.

    It can be used as a BaseClass to implement a Task, that checks for new data to be processed
    by looking at the modification timestamp of the files in the root_path.

    It does this as follows:
    - if there is no target_path yet, it will process the content in the root_path,
      write the result in the target_path together with a meta.inf file that contains
      the newest modification timestamp of all the files in the root_path.
    - if there is a target_path, then it reads the timestamp, that is stored within the target_path.
      It any of the files within the root_path has a newer modification timestamp, it will
      process the data and also update the timestamp in the meta.inf file
    &#34;&#34;&#34;

    def __init__(self, root_paths: List[Path], pathfilter: str, target_path: Path):
        &#34;&#34;&#34;
        The constructor of the CheckByTimestampMergeBaseTask.
        Check also the documentation of the AbstractTask Constructor.
        &#34;&#34;&#34;
        super().__init__(root_paths=root_paths, pathfilter=pathfilter, target_path=target_path)

        if self.meta_inf_file.exists():
            # if the meta_inf file exists, we expect that the first row contains the
            # latest modification timestamp of all files in the root_path, that was
            # processed the last time.
            containing_values = self.read_metainf_content()
            last_processed_timestamp = float(containing_values[0])

            # go and find the current latest modification timestamp of allfiles in the root_path
            current_timestamp = get_latest_mtime(self.root_paths)

            # if the current_timestamp is equal to the last_processed_timestamp,
            # it means that the data in the root_path weren&#39;t changed and therefore,
            # no processing has to be done. We mark this by setting pats_to_process to an empty list
            if current_timestamp &lt;= last_processed_timestamp:
                self.paths_to_process = []

    def execute(self):
        &#34;&#34;&#34;
        Basic implementation of the execute method.

        If there are &#34;paths_to_process&#34;, what has to be done depending on &#34;check_by_timestamp&#34;
        being true or not.

        Returns:

        &#34;&#34;&#34;
        if not self.has_work_todo():
            return

        self.do_execution(paths_to_process=self.paths_to_process, tmp_path=self.tmp_path)

        meta_inf_content: str = str(get_latest_mtime(self.root_paths))
        self.write_meta_inf(content=meta_inf_content)

    @abstractmethod
    def do_execution(self, paths_to_process: List[Path], tmp_path: Path):
        &#34;&#34;&#34;
            defines the logic to be executed.
        Args:
            paths_to_process: lists of paths/folders that have to be processed
            tmp_path: path to where a result has to be written
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractTask" href="#secfsdstools.c_automation.task_framework.AbstractTask">AbstractTask</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.g_pipelines.concat_process.ConcatIfChangedTimestampTask" href="../g_pipelines/concat_process.html#secfsdstools.g_pipelines.concat_process.ConcatIfChangedTimestampTask">ConcatIfChangedTimestampTask</a></li>
<li><a title="secfsdstools.g_pipelines.standardize_process.StandardizerTask" href="../g_pipelines/standardize_process.html#secfsdstools.g_pipelines.standardize_process.StandardizerTask">StandardizerTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask.do_execution"><code class="name flex">
<span>def <span class="ident">do_execution</span></span>(<span>self, paths_to_process:Â List[pathlib.Path], tmp_path:Â pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>defines the logic to be executed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths_to_process</code></strong></dt>
<dd>lists of paths/folders that have to be processed</dd>
<dt><strong><code>tmp_path</code></strong></dt>
<dd>path to where a result has to be written</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def do_execution(self, paths_to_process: List[Path], tmp_path: Path):
    &#34;&#34;&#34;
        defines the logic to be executed.
    Args:
        paths_to_process: lists of paths/folders that have to be processed
        tmp_path: path to where a result has to be written
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic implementation of the execute method.</p>
<p>If there are "paths_to_process", what has to be done depending on "check_by_timestamp"
being true or not.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#34;&#34;&#34;
    Basic implementation of the execute method.

    If there are &#34;paths_to_process&#34;, what has to be done depending on &#34;check_by_timestamp&#34;
    being true or not.

    Returns:

    &#34;&#34;&#34;
    if not self.has_work_todo():
        return

    self.do_execution(paths_to_process=self.paths_to_process, tmp_path=self.tmp_path)

    meta_inf_content: str = str(get_latest_mtime(self.root_paths))
    self.write_meta_inf(content=meta_inf_content)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.c_automation.task_framework.AbstractTask" href="#secfsdstools.c_automation.task_framework.AbstractTask">AbstractTask</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.commit" href="#secfsdstools.c_automation.task_framework.AbstractTask.commit">commit</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.exception" href="#secfsdstools.c_automation.task_framework.AbstractTask.exception">exception</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo" href="#secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo">has_work_todo</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.prepare" href="#secfsdstools.c_automation.task_framework.AbstractTask.prepare">prepare</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content" href="#secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content">read_metainf_content</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf" href="#secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf">write_meta_inf</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.c_automation.task_framework.LoggingProcess"><code class="flex name class">
<span>class <span class="ident">LoggingProcess</span></span>
<span>(</span><span>title:Â str, lines:Â List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Simple process that just logs some information.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>title</code></strong></dt>
<dd>title of the process</dd>
<dt><strong><code>lines</code></strong></dt>
<dd>list of lines to be logged</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoggingProcess(AbstractProcess):
    &#34;&#34;&#34;
    Simple process that just logs some information.
    &#34;&#34;&#34;

    def __init__(self, title: str, lines: List[str]):
        &#34;&#34;&#34;
        Constructor.
        Args:
            title: title of the process
            lines: list of lines to be logged
        &#34;&#34;&#34;
        super().__init__()
        self.title = title
        self.lines = lines

    def process(self):
        &#34;&#34;&#34;execute the process.&#34;&#34;&#34;
        logger = logging.getLogger()

        length_title = len(self.title)

        logger.info(&#34;&#34;)
        logger.info(&#34;#&#34; * (length_title + 4))
        logger.info(&#34;%s&#34;, self.title)

        for line in self.lines:
            logger.info(&#34;    %s&#34;, line)

        logger.info(&#34;#&#34; * (length_title + 4))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.LoggingProcess.process"><code class="name flex">
<span>def <span class="ident">process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>execute the process.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process(self):
    &#34;&#34;&#34;execute the process.&#34;&#34;&#34;
    logger = logging.getLogger()

    length_title = len(self.title)

    logger.info(&#34;&#34;)
    logger.info(&#34;#&#34; * (length_title + 4))
    logger.info(&#34;%s&#34;, self.title)

    for line in self.lines:
        logger.info(&#34;    %s&#34;, line)

    logger.info(&#34;#&#34; * (length_title + 4))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.c_automation.task_framework.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Task interface.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task(Protocol):
    &#34;&#34;&#34;
    Task interface.
    &#34;&#34;&#34;

    def prepare(self):
        &#34;&#34;&#34;Prepare everything to execute the task.
        E.g., creation or clearing a directory.&#34;&#34;&#34;

    def execute(self):
        &#34;&#34;&#34;Execution the task.&#34;&#34;&#34;

    def commit(self) -&gt; Any:
        &#34;&#34;&#34;Commit the task if the execution method is not &#34;self-commiting&#34;. E.g.,
        If you do some file processing in the execute-method,
        but want to update a state in a table,
        you could do the update of the state in the commit method.
        &#34;&#34;&#34;

    def exception(self, exception) -&gt; Any:
        &#34;&#34;&#34;Handle the exception.&#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>typing.Protocol</li>
<li>typing.Generic</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.Task.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Commit the task if the execution method is not "self-commiting". E.g.,
If you do some file processing in the execute-method,
but want to update a state in a table,
you could do the update of the state in the commit method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self) -&gt; Any:
    &#34;&#34;&#34;Commit the task if the execution method is not &#34;self-commiting&#34;. E.g.,
    If you do some file processing in the execute-method,
    but want to update a state in a table,
    you could do the update of the state in the commit method.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.Task.exception"><code class="name flex">
<span>def <span class="ident">exception</span></span>(<span>self, exception) â€‘>Â Any</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exception(self, exception) -&gt; Any:
    &#34;&#34;&#34;Handle the exception.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.Task.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Execution the task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#34;&#34;&#34;Execution the task.&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.c_automation.task_framework.Task.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare everything to execute the task.
E.g., creation or clearing a directory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34;Prepare everything to execute the task.
    E.g., creation or clearing a directory.&#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.c_automation.task_framework.TaskResult"><code class="flex name class">
<span>class <span class="ident">TaskResult</span></span>
<span>(</span><span>task:Â <a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a>, result:Â Any, state:Â <a title="secfsdstools.c_automation.task_framework.TaskResultState" href="#secfsdstools.c_automation.task_framework.TaskResultState">TaskResultState</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Dataclass containing the result of a task.
Contains the task, the TaskResultState and the result (either the return value form the commit()
or exception() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TaskResult:
    &#34;&#34;&#34;
    Dataclass containing the result of a task.
    Contains the task, the TaskResultState and the result (either the return value form the commit()
    or exception() method.
    &#34;&#34;&#34;

    task: Task
    result: Any
    state: TaskResultState</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.TaskResult.result"><code class="name">var <span class="ident">result</span> :Â Any</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.c_automation.task_framework.TaskResult.state"><code class="name">var <span class="ident">state</span> :Â <a title="secfsdstools.c_automation.task_framework.TaskResultState" href="#secfsdstools.c_automation.task_framework.TaskResultState">TaskResultState</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.c_automation.task_framework.TaskResult.task"><code class="name">var <span class="ident">task</span> :Â <a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="secfsdstools.c_automation.task_framework.TaskResultState"><code class="flex name class">
<span>class <span class="ident">TaskResultState</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum defining possible ResultStates of one task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskResultState(Enum):
    &#34;&#34;&#34;
    Enum defining possible ResultStates of one task.
    &#34;&#34;&#34;

    SUCCESS = 1
    FAILED = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="secfsdstools.c_automation.task_framework.TaskResultState.FAILED"><code class="name">var <span class="ident">FAILED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="secfsdstools.c_automation.task_framework.TaskResultState.SUCCESS"><code class="name">var <span class="ident">SUCCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="secfsdstools.c_automation" href="index.html">secfsdstools.c_automation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.execute_processes" href="#secfsdstools.c_automation.task_framework.execute_processes">execute_processes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></code></h4>
<ul class="two-column">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.calculate_tasks">calculate_tasks</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.do_execution" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.do_execution">do_execution</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process">post_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.pre_process">pre_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process">process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task" href="#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task">process_task</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractProcess.process" href="#secfsdstools.c_automation.task_framework.AbstractProcess.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess" href="#secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess">AbstractProcessPoolProcess</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess.do_execution" href="#secfsdstools.c_automation.task_framework.AbstractProcessPoolProcess.do_execution">do_execution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.AbstractTask" href="#secfsdstools.c_automation.task_framework.AbstractTask">AbstractTask</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.commit" href="#secfsdstools.c_automation.task_framework.AbstractTask.commit">commit</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.exception" href="#secfsdstools.c_automation.task_framework.AbstractTask.exception">exception</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo" href="#secfsdstools.c_automation.task_framework.AbstractTask.has_work_todo">has_work_todo</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.prepare" href="#secfsdstools.c_automation.task_framework.AbstractTask.prepare">prepare</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content" href="#secfsdstools.c_automation.task_framework.AbstractTask.read_metainf_content">read_metainf_content</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf" href="#secfsdstools.c_automation.task_framework.AbstractTask.write_meta_inf">write_meta_inf</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess" href="#secfsdstools.c_automation.task_framework.AbstractThreadProcess">AbstractThreadProcess</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess.do_execution" href="#secfsdstools.c_automation.task_framework.AbstractThreadProcess.do_execution">do_execution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask" href="#secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask">CheckByNewSubfoldersMergeBaseTask</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask.do_execution" href="#secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask.do_execution">do_execution</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask.execute" href="#secfsdstools.c_automation.task_framework.CheckByNewSubfoldersMergeBaseTask.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask" href="#secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask">CheckByTimestampMergeBaseTask</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask.do_execution" href="#secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask.do_execution">do_execution</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask.execute" href="#secfsdstools.c_automation.task_framework.CheckByTimestampMergeBaseTask.execute">execute</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.LoggingProcess" href="#secfsdstools.c_automation.task_framework.LoggingProcess">LoggingProcess</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.LoggingProcess.process" href="#secfsdstools.c_automation.task_framework.LoggingProcess.process">process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.Task" href="#secfsdstools.c_automation.task_framework.Task">Task</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.Task.commit" href="#secfsdstools.c_automation.task_framework.Task.commit">commit</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.Task.exception" href="#secfsdstools.c_automation.task_framework.Task.exception">exception</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.Task.execute" href="#secfsdstools.c_automation.task_framework.Task.execute">execute</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.Task.prepare" href="#secfsdstools.c_automation.task_framework.Task.prepare">prepare</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.TaskResult" href="#secfsdstools.c_automation.task_framework.TaskResult">TaskResult</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.TaskResult.result" href="#secfsdstools.c_automation.task_framework.TaskResult.result">result</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.TaskResult.state" href="#secfsdstools.c_automation.task_framework.TaskResult.state">state</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.TaskResult.task" href="#secfsdstools.c_automation.task_framework.TaskResult.task">task</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.c_automation.task_framework.TaskResultState" href="#secfsdstools.c_automation.task_framework.TaskResultState">TaskResultState</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.c_automation.task_framework.TaskResultState.FAILED" href="#secfsdstools.c_automation.task_framework.TaskResultState.FAILED">FAILED</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.TaskResultState.SUCCESS" href="#secfsdstools.c_automation.task_framework.TaskResultState.SUCCESS">SUCCESS</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>