<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>secfsdstools.g_pipelines.filter_process API documentation</title>
<meta name="description" content="Defines pipeline steps that help with applying the same pathfilter to mutilple subfolders
in parallel." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>secfsdstools.g_pipelines.filter_process</code></h1>
</header>
<section id="section-intro">
<p>Defines pipeline steps that help with applying the same pathfilter to mutilple subfolders
in parallel.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Defines pipeline steps that help with applying the same pathfilter to mutilple subfolders
in parallel.
&#34;&#34;&#34;
import os
import shutil
from pathlib import Path
from typing import Callable, List

from secfsdstools.a_utils.fileutils import get_directories_in_directory
from secfsdstools.c_automation.automation_utils import delete_temp_folders
from secfsdstools.c_automation.task_framework import AbstractThreadProcess, Task
from secfsdstools.c_index.indexdataaccess import ParquetDBIndexingAccessor
from secfsdstools.d_container.databagmodel import RawDataBag
from secfsdstools.e_collector.zipcollecting import ZipCollector
from secfsdstools.e_filter.joinedfiltering import StmtJoinedFilter
from secfsdstools.e_filter.rawfiltering import StmtRawFilter


def postloadfilter(databag: RawDataBag) -&gt; RawDataBag:
    &#34;&#34;&#34;
    defines a post pathfilter method that can be used by ZipCollectors.
    It combines the filters:
            ReportPeriodRawFilter, MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter
    &#34;&#34;&#34;
    # pylint: disable=C0415
    from secfsdstools.e_filter.rawfiltering import (
        MainCoregRawFilter,
        OfficialTagsOnlyRawFilter,
        ReportPeriodRawFilter,
        USDOnlyRawFilter,
    )

    return databag[ReportPeriodRawFilter()][MainCoregRawFilter()][USDOnlyRawFilter()][
        OfficialTagsOnlyRawFilter()]


class AbstractFilterTask:
    &#34;&#34;&#34;
    Abstract FilterTask provides some common basic features.
    Uses the ZipCollector to read the raw databags.
    &#34;&#34;&#34;

    def __init__(self,
                 zip_file_name: str,
                 target_path: Path,
                 bag_type: str,  # raw or joined
                 stmts: List[str],
                 forms_filter=None,
                 post_load_filter: Callable[[RawDataBag], RawDataBag] = postloadfilter
                 ):
        &#34;&#34;&#34;
        Constructor.

        Args:
            zip_file_name: name of the source file that shall be readed by the  zipcollector
            target_path: path to store the filtered bag to
            bag_type: bag type (either &#34;row&#34; or &#34;joined&#34;) to save the data as
            stmts: stmts to pathfilter for (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...)
            forms_filter: defines which forms shall be loaded. default is [&#39;10-K&#39;, &#39;10-Q&#39;]
            post_load_filter: pathfilter method to be applied after loading of the zip file.
                              default postloadfilter applies ReportPeriodRawFilter,
                              MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter
        &#34;&#34;&#34;
        if forms_filter is None:
            forms_filter = [&#39;10-K&#39;, &#39;10-Q&#39;]
        self.forms_filter = forms_filter
        self.post_load_filter = post_load_filter

        self.target_path = target_path
        self.stmts = stmts
        self.bag_type = bag_type

        self.zip_file_name = zip_file_name
        self.target_file_name = target_path.name
        self.tmp_path = target_path.parent / f&#34;tmp_{self.target_file_name}&#34;

    def commit(self):
        &#34;&#34;&#34;
        we commit by renaming the tmp_path. This is an atomic action and either fails
        or succeeds. So if there is a tmp folder, we know that something failed and therefore,
        it is easy to recover and redo.
        &#34;&#34;&#34;
        self.tmp_path.rename(self.target_path)
        return &#34;success&#34;

    def exception(self, exception) -&gt; str:
        &#34;&#34;&#34; delete the temp folder. &#34;&#34;&#34;
        shutil.rmtree(self.tmp_path, ignore_errors=True)
        return f&#34;failed {exception}&#34;


class FilterTask(AbstractFilterTask):
    &#34;&#34;&#34;
    Basic Filter implementation which applys the configured pathfilter
    (as defined in the constructor).
    &#34;&#34;&#34;

    def prepare(self):
        &#34;&#34;&#34; prepare the task -&gt; create the tmp_dir. &#34;&#34;&#34;
        self.tmp_path.mkdir(parents=True, exist_ok=False)

    def execute(self):
        &#34;&#34;&#34;
        Uses the ZipCollector to read the input data and then applys the filters as defined
        in the constructor.
        Saves the result depending on the configuration either as raw or joined data bag in the
        defined target path.
        &#34;&#34;&#34;
        raw_bag = ZipCollector.get_zip_by_name(name=self.zip_file_name,
                                               forms_filter=self.forms_filter,
                                               stmt_filter=self.stmts,
                                               post_load_filter=self.post_load_filter).collect()

        if self.bag_type.lower() == &#34;raw&#34;:
            raw_bag.save(str(self.tmp_path))
        elif self.bag_type.lower() == &#34;joined&#34;:
            joined_bag = raw_bag.join()
            joined_bag.save(str(self.tmp_path))
        else:
            raise ValueError(&#34;bag_type must be either raw or joined&#34;)

    def __str__(self) -&gt; str:
        return f&#34;FilterTask(filtered_path: {self.target_path})&#34;


class ByStmtFilterTask(AbstractFilterTask):
    &#34;&#34;&#34;
    Basic Filter implementation which applys the configured filters.

    Depending on the configuration, the results are either saved in raw or joined format.

    Moreover, the result is split up by stmt (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...) when being saved.
    &#34;&#34;&#34;

    def prepare(self):
        &#34;&#34;&#34; prepare Task -&gt; create the tmp_folders with subfolders for every stmt.&#34;&#34;&#34;

        for stmt in self.stmts:
            (self.tmp_path / stmt).mkdir(parents=True, exist_ok=False)

    def execute(self):
        &#34;&#34;&#34;
        Uses the ZipCollector to read the input data and then applys the filters as
        defined in the constructor.

        Saves the result depending on the configuration either as raw or joined data bag.

        Splits the results up by stmt (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...).

        &#34;&#34;&#34;
        raw_bag = ZipCollector.get_zip_by_name(name=self.zip_file_name,
                                               forms_filter=self.forms_filter,
                                               stmt_filter=self.stmts,
                                               post_load_filter=self.post_load_filter).collect()

        if self.bag_type.lower() == &#34;raw&#34;:
            self._execute_raw(raw_bag)
        elif self.bag_type.lower() == &#34;joined&#34;:
            self._execute_joined(raw_bag)
        else:
            raise ValueError(&#34;bag_type must be either raw or joined&#34;)

    def _execute_raw(self, raw_bag: RawDataBag):
        for stmt in self.stmts:
            raw_bag[StmtRawFilter(stmts=[stmt])].save(str(self.tmp_path / stmt))

    def _execute_joined(self, raw_bag: RawDataBag):
        joined_bag = raw_bag.join()

        for stmt in self.stmts:
            joined_bag[StmtJoinedFilter(stmts=[stmt])].save(str(self.tmp_path / stmt))

    def __str__(self) -&gt; str:
        return f&#34;ByStmtFilterTask(filtered_path: {self.target_path})&#34;


class FilterProcess(AbstractThreadProcess):
    &#34;&#34;&#34;
    Applies basic filters on the raw indexed files and saves the result into the provided
    target_path.

    Does it per zip-file and can do it in parallel, depending on the parameter settings.

    Applies the basic filters as defined.
    &#34;&#34;&#34;

    def __init__(self,
                 db_dir: str,
                 target_dir: str,
                 bag_type: str = &#34;joined&#34;,  # raw or joined
                 file_type: str = &#34;quarter&#34;,
                 save_by_stmt: bool = False,
                 stmts=None,
                 execute_serial: bool = False,
                 forms_filter=None,
                 post_load_filter: Callable[[RawDataBag], RawDataBag] = postloadfilter
                 ):
        &#34;&#34;&#34;
        Constructor.

        Args:
            db_dir: directory of the sqlite-db file. Used to read the available zipfiles.
            target_dir: directory to where the results have to be written
            bag_type: either &#34;raw&#34; or &#34;joined&#34; and defines what bag-type shall be written.
                      default is &#34;joined&#34;.
            file_type: the file type to be processed, default is &#34;quarter&#34;
            save_by_stmt: Flag to indicate whether the results should be split up by the stmt.
                          If it is true, subfolders for every stmt &#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ... will be
                          created.
            stmts: The list of stmts that should be filtered: &#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ... or none
            execute_serial: Flag to indicate whether the files should be process in serial manner.
            post_load_filter: postload-pathfilter function. Default is the defined
                              postloadfilter-function.
            forms_filter: defines which forms to laod (10-K, 10-Q, ...). Default is 10-K and 10-Q.
        &#34;&#34;&#34;
        super().__init__(execute_serial=execute_serial,
                         chunksize=0)
        if forms_filter is None:
            forms_filter = [&#39;10-K&#39;, &#39;10-Q&#39;]

        self.forms_filter = forms_filter
        self.post_load_filter = post_load_filter

        self.stmts = [&#39;BS&#39;, &#39;IS&#39;, &#39;CF&#39;, &#39;CP&#39;, &#39;CI&#39;, &#39;EQ&#39;]

        if stmts:
            self.stmts = stmts

        self.dbaccessor = ParquetDBIndexingAccessor(db_dir=db_dir)

        self.target_dir = target_dir
        self.file_type = file_type
        self.bag_type = bag_type
        self.save_by_stmt = save_by_stmt

    def _get_existing_filtered(self):
        return get_directories_in_directory(
            os.path.join(self.target_dir, self.file_type))

    def pre_process(self):
        &#34;&#34;&#34;
        pre-processing: delete any existing tmpfolder in the target folder
        &#34;&#34;&#34;
        delete_temp_folders(root_path=Path(self.target_dir) / self.file_type)

    def calculate_tasks(self) -&gt; List[Task]:
        &#34;&#34;&#34;
        Defines the zipfiles that have not yet been processed and creates appropriate
        processing FilterTasks for every unprocessed zipfile.

        Returns:
            List[Task]: List with Tasks.
        &#34;&#34;&#34;
        existing = self._get_existing_filtered()
        available = self.dbaccessor.read_filenames_by_type(originFileType=self.file_type)

        missings = set(available) - set(existing)
        if self.save_by_stmt:
            return [ByStmtFilterTask(
                zip_file_name=missing,
                target_path=Path(self.target_dir) / self.file_type / missing,
                stmts=self.stmts,
                bag_type=self.bag_type,
                forms_filter=self.forms_filter,
                post_load_filter=self.post_load_filter
            )
                for missing in missings]

        return [FilterTask(
            zip_file_name=missing,
            target_path=Path(self.target_dir) / self.file_type / missing,
            stmts=self.stmts,
            bag_type=self.bag_type,
            forms_filter=self.forms_filter,
            post_load_filter=self.post_load_filter
        )
            for missing in missings]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="secfsdstools.g_pipelines.filter_process.postloadfilter"><code class="name flex">
<span>def <span class="ident">postloadfilter</span></span>(<span>databag: <a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>) ‑> <a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a></span>
</code></dt>
<dd>
<div class="desc"><p>defines a post pathfilter method that can be used by ZipCollectors.
It combines the filters:
ReportPeriodRawFilter, MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def postloadfilter(databag: RawDataBag) -&gt; RawDataBag:
    &#34;&#34;&#34;
    defines a post pathfilter method that can be used by ZipCollectors.
    It combines the filters:
            ReportPeriodRawFilter, MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter
    &#34;&#34;&#34;
    # pylint: disable=C0415
    from secfsdstools.e_filter.rawfiltering import (
        MainCoregRawFilter,
        OfficialTagsOnlyRawFilter,
        ReportPeriodRawFilter,
        USDOnlyRawFilter,
    )

    return databag[ReportPeriodRawFilter()][MainCoregRawFilter()][USDOnlyRawFilter()][
        OfficialTagsOnlyRawFilter()]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="secfsdstools.g_pipelines.filter_process.AbstractFilterTask"><code class="flex name class">
<span>class <span class="ident">AbstractFilterTask</span></span>
<span>(</span><span>zip_file_name: str, target_path: pathlib.Path, bag_type: str, stmts: List[str], forms_filter=None, post_load_filter: Callable[[<a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>], <a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>] = &lt;function postloadfilter&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract FilterTask provides some common basic features.
Uses the ZipCollector to read the raw databags.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zip_file_name</code></strong></dt>
<dd>name of the source file that shall be readed by the
zipcollector</dd>
<dt><strong><code>target_path</code></strong></dt>
<dd>path to store the filtered bag to</dd>
<dt><strong><code>bag_type</code></strong></dt>
<dd>bag type (either "row" or "joined") to save the data as</dd>
<dt><strong><code>stmts</code></strong></dt>
<dd>stmts to pathfilter for ("BS", "IS", "CF", &hellip;)</dd>
<dt><strong><code>forms_filter</code></strong></dt>
<dd>defines which forms shall be loaded. default is ['10-K', '10-Q']</dd>
<dt><strong><code>post_load_filter</code></strong></dt>
<dd>pathfilter method to be applied after loading of the zip file.
default postloadfilter applies ReportPeriodRawFilter,
MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbstractFilterTask:
    &#34;&#34;&#34;
    Abstract FilterTask provides some common basic features.
    Uses the ZipCollector to read the raw databags.
    &#34;&#34;&#34;

    def __init__(self,
                 zip_file_name: str,
                 target_path: Path,
                 bag_type: str,  # raw or joined
                 stmts: List[str],
                 forms_filter=None,
                 post_load_filter: Callable[[RawDataBag], RawDataBag] = postloadfilter
                 ):
        &#34;&#34;&#34;
        Constructor.

        Args:
            zip_file_name: name of the source file that shall be readed by the  zipcollector
            target_path: path to store the filtered bag to
            bag_type: bag type (either &#34;row&#34; or &#34;joined&#34;) to save the data as
            stmts: stmts to pathfilter for (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...)
            forms_filter: defines which forms shall be loaded. default is [&#39;10-K&#39;, &#39;10-Q&#39;]
            post_load_filter: pathfilter method to be applied after loading of the zip file.
                              default postloadfilter applies ReportPeriodRawFilter,
                              MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter
        &#34;&#34;&#34;
        if forms_filter is None:
            forms_filter = [&#39;10-K&#39;, &#39;10-Q&#39;]
        self.forms_filter = forms_filter
        self.post_load_filter = post_load_filter

        self.target_path = target_path
        self.stmts = stmts
        self.bag_type = bag_type

        self.zip_file_name = zip_file_name
        self.target_file_name = target_path.name
        self.tmp_path = target_path.parent / f&#34;tmp_{self.target_file_name}&#34;

    def commit(self):
        &#34;&#34;&#34;
        we commit by renaming the tmp_path. This is an atomic action and either fails
        or succeeds. So if there is a tmp folder, we know that something failed and therefore,
        it is easy to recover and redo.
        &#34;&#34;&#34;
        self.tmp_path.rename(self.target_path)
        return &#34;success&#34;

    def exception(self, exception) -&gt; str:
        &#34;&#34;&#34; delete the temp folder. &#34;&#34;&#34;
        shutil.rmtree(self.tmp_path, ignore_errors=True)
        return f&#34;failed {exception}&#34;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask" href="#secfsdstools.g_pipelines.filter_process.ByStmtFilterTask">ByStmtFilterTask</a></li>
<li><a title="secfsdstools.g_pipelines.filter_process.FilterTask" href="#secfsdstools.g_pipelines.filter_process.FilterTask">FilterTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>we commit by renaming the tmp_path. This is an atomic action and either fails
or succeeds. So if there is a tmp folder, we know that something failed and therefore,
it is easy to recover and redo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self):
    &#34;&#34;&#34;
    we commit by renaming the tmp_path. This is an atomic action and either fails
    or succeeds. So if there is a tmp folder, we know that something failed and therefore,
    it is easy to recover and redo.
    &#34;&#34;&#34;
    self.tmp_path.rename(self.target_path)
    return &#34;success&#34;</code></pre>
</details>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception"><code class="name flex">
<span>def <span class="ident">exception</span></span>(<span>self, exception) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>delete the temp folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exception(self, exception) -&gt; str:
    &#34;&#34;&#34; delete the temp folder. &#34;&#34;&#34;
    shutil.rmtree(self.tmp_path, ignore_errors=True)
    return f&#34;failed {exception}&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask"><code class="flex name class">
<span>class <span class="ident">ByStmtFilterTask</span></span>
<span>(</span><span>zip_file_name: str, target_path: pathlib.Path, bag_type: str, stmts: List[str], forms_filter=None, post_load_filter: Callable[[<a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>], <a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>] = &lt;function postloadfilter&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic Filter implementation which applys the configured filters.</p>
<p>Depending on the configuration, the results are either saved in raw or joined format.</p>
<p>Moreover, the result is split up by stmt ("BS", "IS", "CF", &hellip;) when being saved.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zip_file_name</code></strong></dt>
<dd>name of the source file that shall be readed by the
zipcollector</dd>
<dt><strong><code>target_path</code></strong></dt>
<dd>path to store the filtered bag to</dd>
<dt><strong><code>bag_type</code></strong></dt>
<dd>bag type (either "row" or "joined") to save the data as</dd>
<dt><strong><code>stmts</code></strong></dt>
<dd>stmts to pathfilter for ("BS", "IS", "CF", &hellip;)</dd>
<dt><strong><code>forms_filter</code></strong></dt>
<dd>defines which forms shall be loaded. default is ['10-K', '10-Q']</dd>
<dt><strong><code>post_load_filter</code></strong></dt>
<dd>pathfilter method to be applied after loading of the zip file.
default postloadfilter applies ReportPeriodRawFilter,
MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ByStmtFilterTask(AbstractFilterTask):
    &#34;&#34;&#34;
    Basic Filter implementation which applys the configured filters.

    Depending on the configuration, the results are either saved in raw or joined format.

    Moreover, the result is split up by stmt (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...) when being saved.
    &#34;&#34;&#34;

    def prepare(self):
        &#34;&#34;&#34; prepare Task -&gt; create the tmp_folders with subfolders for every stmt.&#34;&#34;&#34;

        for stmt in self.stmts:
            (self.tmp_path / stmt).mkdir(parents=True, exist_ok=False)

    def execute(self):
        &#34;&#34;&#34;
        Uses the ZipCollector to read the input data and then applys the filters as
        defined in the constructor.

        Saves the result depending on the configuration either as raw or joined data bag.

        Splits the results up by stmt (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...).

        &#34;&#34;&#34;
        raw_bag = ZipCollector.get_zip_by_name(name=self.zip_file_name,
                                               forms_filter=self.forms_filter,
                                               stmt_filter=self.stmts,
                                               post_load_filter=self.post_load_filter).collect()

        if self.bag_type.lower() == &#34;raw&#34;:
            self._execute_raw(raw_bag)
        elif self.bag_type.lower() == &#34;joined&#34;:
            self._execute_joined(raw_bag)
        else:
            raise ValueError(&#34;bag_type must be either raw or joined&#34;)

    def _execute_raw(self, raw_bag: RawDataBag):
        for stmt in self.stmts:
            raw_bag[StmtRawFilter(stmts=[stmt])].save(str(self.tmp_path / stmt))

    def _execute_joined(self, raw_bag: RawDataBag):
        joined_bag = raw_bag.join()

        for stmt in self.stmts:
            joined_bag[StmtJoinedFilter(stmts=[stmt])].save(str(self.tmp_path / stmt))

    def __str__(self) -&gt; str:
        return f&#34;ByStmtFilterTask(filtered_path: {self.target_path})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask">AbstractFilterTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the ZipCollector to read the input data and then applys the filters as
defined in the constructor.</p>
<p>Saves the result depending on the configuration either as raw or joined data bag.</p>
<p>Splits the results up by stmt ("BS", "IS", "CF", &hellip;).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#34;&#34;&#34;
    Uses the ZipCollector to read the input data and then applys the filters as
    defined in the constructor.

    Saves the result depending on the configuration either as raw or joined data bag.

    Splits the results up by stmt (&#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ...).

    &#34;&#34;&#34;
    raw_bag = ZipCollector.get_zip_by_name(name=self.zip_file_name,
                                           forms_filter=self.forms_filter,
                                           stmt_filter=self.stmts,
                                           post_load_filter=self.post_load_filter).collect()

    if self.bag_type.lower() == &#34;raw&#34;:
        self._execute_raw(raw_bag)
    elif self.bag_type.lower() == &#34;joined&#34;:
        self._execute_joined(raw_bag)
    else:
        raise ValueError(&#34;bag_type must be either raw or joined&#34;)</code></pre>
</details>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>prepare Task -&gt; create the tmp_folders with subfolders for every stmt.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34; prepare Task -&gt; create the tmp_folders with subfolders for every stmt.&#34;&#34;&#34;

    for stmt in self.stmts:
        (self.tmp_path / stmt).mkdir(parents=True, exist_ok=False)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask">AbstractFilterTask</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit">commit</a></code></li>
<li><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception">exception</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.FilterProcess"><code class="flex name class">
<span>class <span class="ident">FilterProcess</span></span>
<span>(</span><span>db_dir: str, target_dir: str, bag_type: str = 'joined', file_type: str = 'quarter', save_by_stmt: bool = False, stmts=None, execute_serial: bool = False, forms_filter=None, post_load_filter: Callable[[<a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>], <a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>] = &lt;function postloadfilter&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Applies basic filters on the raw indexed files and saves the result into the provided
target_path.</p>
<p>Does it per zip-file and can do it in parallel, depending on the parameter settings.</p>
<p>Applies the basic filters as defined.</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db_dir</code></strong></dt>
<dd>directory of the sqlite-db file. Used to read the available zipfiles.</dd>
<dt><strong><code>target_dir</code></strong></dt>
<dd>directory to where the results have to be written</dd>
<dt><strong><code>bag_type</code></strong></dt>
<dd>either "raw" or "joined" and defines what bag-type shall be written.
default is "joined".</dd>
<dt><strong><code>file_type</code></strong></dt>
<dd>the file type to be processed, default is "quarter"</dd>
<dt><strong><code>save_by_stmt</code></strong></dt>
<dd>Flag to indicate whether the results should be split up by the stmt.
If it is true, subfolders for every stmt "BS", "IS", "CF", &hellip; will be
created.</dd>
<dt><strong><code>stmts</code></strong></dt>
<dd>The list of stmts that should be filtered: "BS", "IS", "CF", &hellip; or none</dd>
<dt><strong><code>execute_serial</code></strong></dt>
<dd>Flag to indicate whether the files should be process in serial manner.</dd>
<dt><strong><code>post_load_filter</code></strong></dt>
<dd>postload-pathfilter function. Default is the defined
postloadfilter-function.</dd>
<dt><strong><code>forms_filter</code></strong></dt>
<dd>defines which forms to laod (10-K, 10-Q, &hellip;). Default is 10-K and 10-Q.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterProcess(AbstractThreadProcess):
    &#34;&#34;&#34;
    Applies basic filters on the raw indexed files and saves the result into the provided
    target_path.

    Does it per zip-file and can do it in parallel, depending on the parameter settings.

    Applies the basic filters as defined.
    &#34;&#34;&#34;

    def __init__(self,
                 db_dir: str,
                 target_dir: str,
                 bag_type: str = &#34;joined&#34;,  # raw or joined
                 file_type: str = &#34;quarter&#34;,
                 save_by_stmt: bool = False,
                 stmts=None,
                 execute_serial: bool = False,
                 forms_filter=None,
                 post_load_filter: Callable[[RawDataBag], RawDataBag] = postloadfilter
                 ):
        &#34;&#34;&#34;
        Constructor.

        Args:
            db_dir: directory of the sqlite-db file. Used to read the available zipfiles.
            target_dir: directory to where the results have to be written
            bag_type: either &#34;raw&#34; or &#34;joined&#34; and defines what bag-type shall be written.
                      default is &#34;joined&#34;.
            file_type: the file type to be processed, default is &#34;quarter&#34;
            save_by_stmt: Flag to indicate whether the results should be split up by the stmt.
                          If it is true, subfolders for every stmt &#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ... will be
                          created.
            stmts: The list of stmts that should be filtered: &#34;BS&#34;, &#34;IS&#34;, &#34;CF&#34;, ... or none
            execute_serial: Flag to indicate whether the files should be process in serial manner.
            post_load_filter: postload-pathfilter function. Default is the defined
                              postloadfilter-function.
            forms_filter: defines which forms to laod (10-K, 10-Q, ...). Default is 10-K and 10-Q.
        &#34;&#34;&#34;
        super().__init__(execute_serial=execute_serial,
                         chunksize=0)
        if forms_filter is None:
            forms_filter = [&#39;10-K&#39;, &#39;10-Q&#39;]

        self.forms_filter = forms_filter
        self.post_load_filter = post_load_filter

        self.stmts = [&#39;BS&#39;, &#39;IS&#39;, &#39;CF&#39;, &#39;CP&#39;, &#39;CI&#39;, &#39;EQ&#39;]

        if stmts:
            self.stmts = stmts

        self.dbaccessor = ParquetDBIndexingAccessor(db_dir=db_dir)

        self.target_dir = target_dir
        self.file_type = file_type
        self.bag_type = bag_type
        self.save_by_stmt = save_by_stmt

    def _get_existing_filtered(self):
        return get_directories_in_directory(
            os.path.join(self.target_dir, self.file_type))

    def pre_process(self):
        &#34;&#34;&#34;
        pre-processing: delete any existing tmpfolder in the target folder
        &#34;&#34;&#34;
        delete_temp_folders(root_path=Path(self.target_dir) / self.file_type)

    def calculate_tasks(self) -&gt; List[Task]:
        &#34;&#34;&#34;
        Defines the zipfiles that have not yet been processed and creates appropriate
        processing FilterTasks for every unprocessed zipfile.

        Returns:
            List[Task]: List with Tasks.
        &#34;&#34;&#34;
        existing = self._get_existing_filtered()
        available = self.dbaccessor.read_filenames_by_type(originFileType=self.file_type)

        missings = set(available) - set(existing)
        if self.save_by_stmt:
            return [ByStmtFilterTask(
                zip_file_name=missing,
                target_path=Path(self.target_dir) / self.file_type / missing,
                stmts=self.stmts,
                bag_type=self.bag_type,
                forms_filter=self.forms_filter,
                post_load_filter=self.post_load_filter
            )
                for missing in missings]

        return [FilterTask(
            zip_file_name=missing,
            target_path=Path(self.target_dir) / self.file_type / missing,
            stmts=self.stmts,
            bag_type=self.bag_type,
            forms_filter=self.forms_filter,
            post_load_filter=self.post_load_filter
        )
            for missing in missings]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractThreadProcess">AbstractThreadProcess</a></li>
<li><a title="secfsdstools.c_automation.task_framework.AbstractParallelProcess" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractParallelProcess">AbstractParallelProcess</a></li>
<li><a title="secfsdstools.c_automation.task_framework.AbstractProcess" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractProcess">AbstractProcess</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.g_pipelines.filter_process.FilterProcess.calculate_tasks"><code class="name flex">
<span>def <span class="ident">calculate_tasks</span></span>(<span>self) ‑> List[<a title="secfsdstools.c_automation.task_framework.Task" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.Task">Task</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Defines the zipfiles that have not yet been processed and creates appropriate
processing FilterTasks for every unprocessed zipfile.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Task]</code></dt>
<dd>List with Tasks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_tasks(self) -&gt; List[Task]:
    &#34;&#34;&#34;
    Defines the zipfiles that have not yet been processed and creates appropriate
    processing FilterTasks for every unprocessed zipfile.

    Returns:
        List[Task]: List with Tasks.
    &#34;&#34;&#34;
    existing = self._get_existing_filtered()
    available = self.dbaccessor.read_filenames_by_type(originFileType=self.file_type)

    missings = set(available) - set(existing)
    if self.save_by_stmt:
        return [ByStmtFilterTask(
            zip_file_name=missing,
            target_path=Path(self.target_dir) / self.file_type / missing,
            stmts=self.stmts,
            bag_type=self.bag_type,
            forms_filter=self.forms_filter,
            post_load_filter=self.post_load_filter
        )
            for missing in missings]

    return [FilterTask(
        zip_file_name=missing,
        target_path=Path(self.target_dir) / self.file_type / missing,
        stmts=self.stmts,
        bag_type=self.bag_type,
        forms_filter=self.forms_filter,
        post_load_filter=self.post_load_filter
    )
        for missing in missings]</code></pre>
</details>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.FilterProcess.pre_process"><code class="name flex">
<span>def <span class="ident">pre_process</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>pre-processing: delete any existing tmpfolder in the target folder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_process(self):
    &#34;&#34;&#34;
    pre-processing: delete any existing tmpfolder in the target folder
    &#34;&#34;&#34;
    delete_temp_folders(root_path=Path(self.target_dir) / self.file_type)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractThreadProcess">AbstractThreadProcess</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess.do_execution" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractThreadProcess.do_execution">do_execution</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess.post_process" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractParallelProcess.post_process">post_process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess.process" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process">process</a></code></li>
<li><code><a title="secfsdstools.c_automation.task_framework.AbstractThreadProcess.process_task" href="../c_automation/task_framework.html#secfsdstools.c_automation.task_framework.AbstractParallelProcess.process_task">process_task</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.FilterTask"><code class="flex name class">
<span>class <span class="ident">FilterTask</span></span>
<span>(</span><span>zip_file_name: str, target_path: pathlib.Path, bag_type: str, stmts: List[str], forms_filter=None, post_load_filter: Callable[[<a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>], <a title="secfsdstools.d_container.databagmodel.RawDataBag" href="../d_container/databagmodel.html#secfsdstools.d_container.databagmodel.RawDataBag">RawDataBag</a>] = &lt;function postloadfilter&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic Filter implementation which applys the configured pathfilter
(as defined in the constructor).</p>
<p>Constructor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>zip_file_name</code></strong></dt>
<dd>name of the source file that shall be readed by the
zipcollector</dd>
<dt><strong><code>target_path</code></strong></dt>
<dd>path to store the filtered bag to</dd>
<dt><strong><code>bag_type</code></strong></dt>
<dd>bag type (either "row" or "joined") to save the data as</dd>
<dt><strong><code>stmts</code></strong></dt>
<dd>stmts to pathfilter for ("BS", "IS", "CF", &hellip;)</dd>
<dt><strong><code>forms_filter</code></strong></dt>
<dd>defines which forms shall be loaded. default is ['10-K', '10-Q']</dd>
<dt><strong><code>post_load_filter</code></strong></dt>
<dd>pathfilter method to be applied after loading of the zip file.
default postloadfilter applies ReportPeriodRawFilter,
MainCoregRawFilter, USDOnlyRawFilter, OfficialTagsOnlyRawFilter</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FilterTask(AbstractFilterTask):
    &#34;&#34;&#34;
    Basic Filter implementation which applys the configured pathfilter
    (as defined in the constructor).
    &#34;&#34;&#34;

    def prepare(self):
        &#34;&#34;&#34; prepare the task -&gt; create the tmp_dir. &#34;&#34;&#34;
        self.tmp_path.mkdir(parents=True, exist_ok=False)

    def execute(self):
        &#34;&#34;&#34;
        Uses the ZipCollector to read the input data and then applys the filters as defined
        in the constructor.
        Saves the result depending on the configuration either as raw or joined data bag in the
        defined target path.
        &#34;&#34;&#34;
        raw_bag = ZipCollector.get_zip_by_name(name=self.zip_file_name,
                                               forms_filter=self.forms_filter,
                                               stmt_filter=self.stmts,
                                               post_load_filter=self.post_load_filter).collect()

        if self.bag_type.lower() == &#34;raw&#34;:
            raw_bag.save(str(self.tmp_path))
        elif self.bag_type.lower() == &#34;joined&#34;:
            joined_bag = raw_bag.join()
            joined_bag.save(str(self.tmp_path))
        else:
            raise ValueError(&#34;bag_type must be either raw or joined&#34;)

    def __str__(self) -&gt; str:
        return f&#34;FilterTask(filtered_path: {self.target_path})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask">AbstractFilterTask</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="secfsdstools.g_pipelines.filter_process.FilterTask.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Uses the ZipCollector to read the input data and then applys the filters as defined
in the constructor.
Saves the result depending on the configuration either as raw or joined data bag in the
defined target path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self):
    &#34;&#34;&#34;
    Uses the ZipCollector to read the input data and then applys the filters as defined
    in the constructor.
    Saves the result depending on the configuration either as raw or joined data bag in the
    defined target path.
    &#34;&#34;&#34;
    raw_bag = ZipCollector.get_zip_by_name(name=self.zip_file_name,
                                           forms_filter=self.forms_filter,
                                           stmt_filter=self.stmts,
                                           post_load_filter=self.post_load_filter).collect()

    if self.bag_type.lower() == &#34;raw&#34;:
        raw_bag.save(str(self.tmp_path))
    elif self.bag_type.lower() == &#34;joined&#34;:
        joined_bag = raw_bag.join()
        joined_bag.save(str(self.tmp_path))
    else:
        raise ValueError(&#34;bag_type must be either raw or joined&#34;)</code></pre>
</details>
</dd>
<dt id="secfsdstools.g_pipelines.filter_process.FilterTask.prepare"><code class="name flex">
<span>def <span class="ident">prepare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>prepare the task -&gt; create the tmp_dir.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prepare(self):
    &#34;&#34;&#34; prepare the task -&gt; create the tmp_dir. &#34;&#34;&#34;
    self.tmp_path.mkdir(parents=True, exist_ok=False)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask">AbstractFilterTask</a></b></code>:
<ul class="hlist">
<li><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit">commit</a></code></li>
<li><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception">exception</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="secfsdstools.g_pipelines" href="index.html">secfsdstools.g_pipelines</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="secfsdstools.g_pipelines.filter_process.postloadfilter" href="#secfsdstools.g_pipelines.filter_process.postloadfilter">postloadfilter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask">AbstractFilterTask</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask.commit">commit</a></code></li>
<li><code><a title="secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception" href="#secfsdstools.g_pipelines.filter_process.AbstractFilterTask.exception">exception</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask" href="#secfsdstools.g_pipelines.filter_process.ByStmtFilterTask">ByStmtFilterTask</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask.execute" href="#secfsdstools.g_pipelines.filter_process.ByStmtFilterTask.execute">execute</a></code></li>
<li><code><a title="secfsdstools.g_pipelines.filter_process.ByStmtFilterTask.prepare" href="#secfsdstools.g_pipelines.filter_process.ByStmtFilterTask.prepare">prepare</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.g_pipelines.filter_process.FilterProcess" href="#secfsdstools.g_pipelines.filter_process.FilterProcess">FilterProcess</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.g_pipelines.filter_process.FilterProcess.calculate_tasks" href="#secfsdstools.g_pipelines.filter_process.FilterProcess.calculate_tasks">calculate_tasks</a></code></li>
<li><code><a title="secfsdstools.g_pipelines.filter_process.FilterProcess.pre_process" href="#secfsdstools.g_pipelines.filter_process.FilterProcess.pre_process">pre_process</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="secfsdstools.g_pipelines.filter_process.FilterTask" href="#secfsdstools.g_pipelines.filter_process.FilterTask">FilterTask</a></code></h4>
<ul class="">
<li><code><a title="secfsdstools.g_pipelines.filter_process.FilterTask.execute" href="#secfsdstools.g_pipelines.filter_process.FilterTask.execute">execute</a></code></li>
<li><code><a title="secfsdstools.g_pipelines.filter_process.FilterTask.prepare" href="#secfsdstools.g_pipelines.filter_process.FilterTask.prepare">prepare</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>